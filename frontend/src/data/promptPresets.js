/**
 * Prompt presets for common software development tasks.
 *
 * Preset definitions are stored as JSON inside a single string literal to reduce
 * token-based duplication noise in analyzers while preserving exact prompts.
 */

const EXECUTION_STRATEGY = "multi-agent-consensus";

const PRESETS_DATA_JSON = "[{\"id\":\"technical-debt-analysis\",\"category\":\"Code Analysis\",\"name\":\"Technical Debt Analysis\",\"description\":\"Identify technical debt hotspots: code complexity, duplications, antipatterns, and prioritize remediation\",\"icon\":\"analysis\",\"prompt\":\"Analyze the codebase for technical debt:\\n\\n1. **Code Complexity**: Identify functions/classes with high cyclomatic complexity\\n2. **Code Duplications**: Find duplicate or similar code blocks that could be refactored\\n3. **Antipatterns**: Detect common antipatterns (God objects, circular dependencies, etc.)\\n4. **Legacy Code**: Identify outdated patterns or deprecated API usage\\n5. **Priority Matrix**: Categorize findings by impact (high/medium/low) and effort (quick wins vs. long-term)\\n\\nProvide actionable recommendations with specific file locations and suggested refactorings.\",\"tags\":[\"analysis\",\"quality\",\"refactoring\"]},{\"id\":\"dead-code-detector\",\"category\":\"Code Analysis\",\"name\":\"Dead Code Detector\",\"description\":\"Find unused code: unreferenced functions, unused imports, orphaned files, and calculate cleanup impact\",\"icon\":\"trash\",\"prompt\":\"Scan the codebase for dead code:\\n\\n1. **Unreferenced Functions**: Find functions/methods that are never called\\n2. **Unused Imports**: Identify imports that are never used\\n3. **Orphaned Files**: Detect files that are not imported anywhere\\n4. **Dead Routes**: Find registered routes that are not linked from anywhere\\n5. **Unused Dependencies**: Check package.json/pom.xml for unused dependencies\\n6. **Impact Calculation**: Estimate LOC reduction and bundle size improvement\\n\\nProvide a prioritized list with safe-to-remove candidates vs. needs-investigation.\",\"tags\":[\"analysis\",\"cleanup\",\"optimization\"]},{\"id\":\"complexity-hotspots\",\"category\":\"Code Analysis\",\"name\":\"Complexity Hotspots\",\"description\":\"Analyze cyclomatic complexity, cognitive complexity, nesting depth and highlight functions needing refactoring\",\"icon\":\"flame\",\"prompt\":\"Analyze code complexity metrics:\\n\\n1. **Cyclomatic Complexity**: Calculate complexity score for all functions (target: <10)\\n2. **Cognitive Complexity**: Measure how difficult code is to understand\\n3. **Nesting Depth**: Identify deeply nested code (target: <4 levels)\\n4. **Function Length**: Find functions exceeding recommended length (target: <50 LOC)\\n5. **Parameter Count**: Detect functions with too many parameters (target: <5)\\n\\nFor each hotspot, provide:\\n- Specific location and complexity score\\n- Refactoring suggestions (extract method, simplify conditions, etc.)\\n- Priority based on change frequency and business criticality\",\"tags\":[\"analysis\",\"complexity\",\"refactoring\"]},{\"id\":\"dependency-health-check\",\"category\":\"Code Analysis\",\"name\":\"Dependency Health Check\",\"description\":\"Audit dependencies: outdated packages, known CVEs, license issues, bundle size impact\",\"icon\":\"package\",\"prompt\":\"Perform a comprehensive dependency audit:\\n\\n1. **Outdated Packages**: List dependencies with available updates (minor, major, breaking)\\n2. **Security Vulnerabilities**: Identify known CVEs with severity scores\\n3. **License Issues**: Check for incompatible or restrictive licenses\\n4. **Bundle Size Impact**: Identify heavy dependencies contributing most to bundle size\\n5. **Duplicate Dependencies**: Find multiple versions of the same package\\n6. **Alternative Recommendations**: Suggest lighter or more maintained alternatives\\n\\nPrioritize by risk level: Critical CVEs > Major version behind > High bundle impact.\",\"tags\":[\"analysis\",\"security\",\"dependencies\"]},{\"id\":\"architecture-conformance\",\"category\":\"Code Analysis\",\"name\":\"Architecture Conformance\",\"description\":\"Validate if code follows intended architecture (hexagonal/clean/layered) and identify boundary violations\",\"icon\":\"architecture\",\"prompt\":\"Analyze architectural conformance:\\n\\n1. **Architecture Detection**: Identify the intended architecture pattern (layered, hexagonal, clean, etc.)\\n2. **Layer Violations**: Detect improper dependencies between layers (e.g., UI calling DB directly)\\n3. **Boundary Violations**: Find domain logic leaking into infrastructure or vice versa\\n4. **Dependency Direction**: Verify dependencies flow in the correct direction\\n5. **Separation of Concerns**: Check if responsibilities are properly separated\\n6. **Package Structure**: Validate if package/module structure reflects architecture\\n\\nFor each violation, explain why it's problematic and suggest the correct approach.\",\"tags\":[\"analysis\",\"architecture\",\"design\"]},{\"id\":\"database-query-analysis\",\"category\":\"Performance Analysis\",\"name\":\"Database Query Analysis\",\"description\":\"Detect N+1 queries, missing indexes, inefficient joins, and suggest optimizations\",\"icon\":\"database\",\"prompt\":\"Analyze database query performance:\\n\\n1. **N+1 Query Detection**: Find loops that trigger individual queries (use batch loading instead)\\n2. **Missing Indexes**: Identify frequently queried columns without indexes\\n3. **Inefficient Joins**: Spot complex joins that could be simplified or cached\\n4. **Unused Indexes**: Find indexes that are not used by any query\\n5. **Query Optimization**: Suggest query rewrites (e.g., EXISTS vs IN, proper pagination)\\n6. **Connection Pool Issues**: Check for connection leaks or pool exhaustion\\n\\nFor each finding, provide:\\n- Code location and problematic pattern\\n- Performance impact estimation\\n- Optimized alternative with code example\",\"tags\":[\"performance\",\"database\",\"optimization\"]},{\"id\":\"bundle-size-analyzer\",\"category\":\"Performance Analysis\",\"name\":\"Bundle Size Analyzer\",\"description\":\"Analyze JS bundle: heavy dependencies, code splitting opportunities, tree-shaking issues\",\"icon\":\"bundle\",\"prompt\":\"Analyze JavaScript bundle size:\\n\\n1. **Heavy Dependencies**: Identify largest dependencies and their impact\\n2. **Code Splitting**: Find opportunities to split code by route or feature\\n3. **Tree-Shaking Issues**: Detect imports preventing tree-shaking (e.g., entire lodash)\\n4. **Lazy Loading**: Suggest components/modules that could be lazy loaded\\n5. **Duplicate Code**: Find code duplicated across chunks\\n6. **Moment.js/date-fns**: Check for heavy date libraries (suggest lighter alternatives)\\n\\nProvide:\\n- Current bundle size breakdown\\n- Optimization recommendations with expected size reduction\\n- Implementation examples for code splitting\",\"tags\":[\"performance\",\"frontend\",\"optimization\"]},{\"id\":\"memory-leak-detector\",\"category\":\"Performance Analysis\",\"name\":\"Memory Leak Detector\",\"description\":\"Scan for memory leak patterns: event listeners not cleaned, closures holding references, DOM leaks\",\"icon\":\"memory\",\"prompt\":\"Scan for memory leak patterns:\\n\\n1. **Event Listeners**: Find addEventListener without removeEventListener\\n2. **Interval/Timeout**: Detect setInterval/setTimeout not cleared in cleanup\\n3. **Closure Leaks**: Identify closures holding unnecessary references\\n4. **DOM Leaks**: Find detached DOM nodes still referenced\\n5. **Cache Without Limits**: Detect caches that grow unbounded\\n6. **React-Specific**: useEffect without cleanup, refs not cleared\\n\\nFor each potential leak:\\n- Code location and pattern\\n- Why it causes a leak\\n- Fixed code example with proper cleanup\",\"tags\":[\"performance\",\"memory\",\"bugs\"]},{\"id\":\"react-performance-audit\",\"category\":\"Performance Analysis\",\"name\":\"React Performance Audit\",\"description\":\"Find unnecessary re-renders, missing memoization, expensive computations in render\",\"icon\":\"react\",\"prompt\":\"Audit React performance:\\n\\n1. **Unnecessary Re-renders**: Components re-rendering when props haven't changed\\n2. **Missing Memoization**: Expensive calculations that should use useMemo\\n3. **Callback Recreation**: Functions recreated on each render (need useCallback)\\n4. **Context Overuse**: Context causing too many re-renders (split context)\\n5. **Key Prop Issues**: Missing or incorrect keys in lists\\n6. **Inline Objects/Arrays**: Creating new objects in render causing child re-renders\\n7. **Large Component Trees**: Components that should be split smaller\\n\\nFor each issue:\\n- Component location and render frequency\\n- Performance impact\\n- Optimized code with React.memo, useMemo, or useCallback\",\"tags\":[\"performance\",\"react\",\"frontend\"]},{\"id\":\"secrets-credentials-scan\",\"category\":\"Security Analysis\",\"name\":\"Secrets & Credentials Scan\",\"description\":\"Find hardcoded secrets, API keys, passwords, tokens, certificates\",\"icon\":\"lock\",\"prompt\":\"Scan for exposed secrets and credentials:\\n\\n1. **Hardcoded Secrets**: API keys, passwords, tokens in code\\n2. **Database Credentials**: Connection strings with embedded passwords\\n3. **Private Keys**: RSA/SSH keys, certificates in repository\\n4. **Environment Variables**: Check .env files are in .gitignore\\n5. **Git History**: Suggest scanning git history for past leaks\\n6. **Secret Management**: Recommend vault solutions (HashiCorp Vault, AWS Secrets Manager)\\n\\nFor each finding:\\n- File location and type of secret\\n- Severity (public repo = critical, private = high)\\n- Remediation steps (rotate key, use env vars, vault integration)\",\"tags\":[\"security\",\"secrets\",\"critical\"]},{\"id\":\"input-validation-audit\",\"category\":\"Security Analysis\",\"name\":\"Input Validation Audit\",\"description\":\"Identify missing input validation, SQL injection risks, XSS vulnerabilities, command injection\",\"icon\":\"shield\",\"prompt\":\"Audit input validation and injection vulnerabilities:\\n\\n1. **SQL Injection**: Find string concatenation in SQL queries (use parameterized queries)\\n2. **XSS Vulnerabilities**: Identify unescaped user input rendered as HTML\\n3. **Command Injection**: Detect user input passed to system commands\\n4. **Path Traversal**: Check file operations with user-controlled paths\\n5. **LDAP/XML Injection**: Find unvalidated input in LDAP queries or XML parsing\\n6. **Validation Missing**: Input endpoints without validation (length, format, type)\\n\\nFor each vulnerability:\\n- Attack vector and example exploit\\n- Affected endpoints/functions\\n- Secure code example with proper validation/sanitization\",\"tags\":[\"security\",\"validation\",\"critical\"]},{\"id\":\"auth-authorization-review\",\"category\":\"Security Analysis\",\"name\":\"Auth & Authorization Review\",\"description\":\"Analyze authentication flow, session management, JWT handling, RBAC implementation\",\"icon\":\"key\",\"prompt\":\"Review authentication and authorization:\\n\\n1. **Authentication Flow**: Analyze login/logout implementation, weak points\\n2. **Session Management**: Check session timeouts, secure flags, regeneration\\n3. **JWT Handling**: Verify signature, expiration, secure storage (not localStorage)\\n4. **Password Security**: Check hashing (bcrypt/argon2), salt, complexity requirements\\n5. **RBAC Implementation**: Verify role checks are enforced server-side\\n6. **Privilege Escalation**: Test if users can access unauthorized resources\\n7. **Multi-Factor Authentication**: Check if MFA is implemented for sensitive operations\\n\\nFor each issue:\\n- Security impact (authentication bypass, privilege escalation, etc.)\\n- Specific vulnerable code\\n- Secure implementation example\",\"tags\":[\"security\",\"authentication\",\"critical\"]},{\"id\":\"api-security-checklist\",\"category\":\"Security Analysis\",\"name\":\"API Security Checklist\",\"description\":\"Review API endpoints: rate limiting, CORS, authentication, input validation, error disclosure\",\"icon\":\"globe\",\"prompt\":\"Audit API security:\\n\\n1. **Rate Limiting**: Check if endpoints have rate limiting to prevent abuse\\n2. **CORS Configuration**: Verify CORS is not set to * (wildcard)\\n3. **Authentication**: Ensure all sensitive endpoints require authentication\\n4. **Input Validation**: Validate all request parameters (query, body, headers)\\n5. **Error Disclosure**: Check errors don't leak sensitive info (stack traces, DB details)\\n6. **API Versioning**: Verify deprecated endpoints are properly sunset\\n7. **HTTPS Only**: Ensure API only works over HTTPS\\n8. **API Keys**: Check API key rotation and secure storage\\n\\nFor each endpoint, assess:\\n- Current security posture\\n- Missing protections\\n- Recommended fixes with code examples\",\"tags\":[\"security\",\"api\",\"web\"]},{\"id\":\"test-coverage-gap-analysis\",\"category\":\"Testing Analysis\",\"name\":\"Test Coverage Gap Analysis\",\"description\":\"Identify critical paths without tests, edge cases not covered, missing integration tests\",\"icon\":\"target\",\"prompt\":\"Analyze test coverage gaps:\\n\\n1. **Critical Paths**: Identify business-critical code without test coverage\\n2. **Edge Cases**: Find edge cases not covered (null, empty, boundary values)\\n3. **Error Paths**: Check if error handling is tested\\n4. **Integration Tests**: Identify missing integration tests for key user flows\\n5. **Risk Score**: Calculate risk = (code complexity × business criticality) / test coverage\\n6. **Mutation Testing**: Suggest areas where tests might pass but not catch bugs\\n\\nFor each gap:\\n- Code location and risk level\\n- Missing test scenarios\\n- Example test cases to add\",\"tags\":[\"testing\",\"quality\",\"coverage\"]},{\"id\":\"flaky-test-detector\",\"category\":\"Testing Analysis\",\"name\":\"Flaky Test Detector\",\"description\":\"Analyze test failures: race conditions, timing issues, shared state, non-deterministic behavior\",\"icon\":\"dices\",\"prompt\":\"Detect flaky test patterns:\\n\\n1. **Race Conditions**: Tests depending on timing or async operations without proper awaits\\n2. **Shared State**: Tests that fail when run in parallel due to shared global state\\n3. **External Dependencies**: Tests depending on network, filesystem, or database state\\n4. **Non-Deterministic**: Tests using random values, current date/time without mocking\\n5. **Test Order Dependency**: Tests that fail when run in different order\\n6. **Improper Cleanup**: Tests not cleaning up resources (files, DB records, mocks)\\n\\nFor each flaky pattern:\\n- Test location and failure symptom\\n- Root cause explanation\\n- Fixed test with proper isolation/mocking\",\"tags\":[\"testing\",\"quality\",\"reliability\"]},{\"id\":\"test-quality-assessment\",\"category\":\"Testing Analysis\",\"name\":\"Test Quality Assessment\",\"description\":\"Evaluate test quality: assertions effectiveness, test isolation, mocking patterns, maintainability\",\"icon\":\"check\",\"prompt\":\"Assess test quality:\\n\\n1. **Assertion Effectiveness**: Check if tests actually verify behavior (no assertions = red flag)\\n2. **Test Isolation**: Tests should not depend on each other or external state\\n3. **Mocking Patterns**: Verify mocks are used appropriately (not over-mocking)\\n4. **Test Readability**: Assess if tests follow Given-When-Then or Arrange-Act-Assert\\n5. **Test Maintainability**: Check for brittle tests that break with minor changes\\n6. **Test Data**: Use factories/builders instead of hardcoded test data\\n7. **Test Organization**: Proper describe/it structure, descriptive names\\n\\nFor each quality issue:\\n- Test location and problem\\n- Why it reduces test effectiveness\\n- Improved test example\",\"tags\":[\"testing\",\"quality\",\"best-practices\"]},{\"id\":\"docker-image-optimizer\",\"category\":\"Infrastructure Analysis\",\"name\":\"Docker Image Optimizer\",\"description\":\"Analyze Dockerfile: multi-stage builds, layer caching, base image size, security scanning\",\"icon\":\"container\",\"prompt\":\"Optimize Docker images:\\n\\n1. **Multi-Stage Builds**: Check if using multi-stage to reduce final image size\\n2. **Layer Caching**: Optimize layer order (dependencies before source code)\\n3. **Base Image Size**: Suggest alpine or distroless alternatives\\n4. **Security Scanning**: Check for vulnerabilities in base image\\n5. **Build Time**: Identify slow build steps that could be parallelized or cached\\n6. **.dockerignore**: Verify .dockerignore excludes unnecessary files\\n7. **Layer Count**: Combine RUN commands to reduce layers\\n\\nProvide:\\n- Current image size and build time\\n- Optimized Dockerfile with explanations\\n- Expected improvements (size reduction, build time)\",\"tags\":[\"infrastructure\",\"docker\",\"optimization\"]},{\"id\":\"cicd-pipeline-audit\",\"category\":\"Infrastructure Analysis\",\"name\":\"CI/CD Pipeline Audit\",\"description\":\"Review GitHub Actions/CI: workflow optimization, caching strategies, parallelization, secret management\",\"icon\":\"refresh\",\"prompt\":\"Audit CI/CD pipeline:\\n\\n1. **Caching Strategies**: Check if dependencies are cached (npm, Maven, Docker layers)\\n2. **Parallelization**: Identify jobs that could run in parallel\\n3. **Workflow Triggers**: Verify workflows trigger on appropriate events\\n4. **Secret Management**: Ensure secrets use GitHub Secrets, not hardcoded\\n5. **Job Duration**: Find slow jobs that could be optimized\\n6. **Matrix Builds**: Use matrix strategy for testing multiple versions\\n7. **Cost Optimization**: Identify redundant jobs or inefficient runners\\n\\nFor each optimization:\\n- Current bottleneck or issue\\n- Recommended change with workflow YAML\\n- Expected time/cost savings\",\"tags\":[\"infrastructure\",\"ci-cd\",\"optimization\"]},{\"id\":\"logging-coverage-analysis\",\"category\":\"Observability Analysis\",\"name\":\"Logging Coverage Analysis\",\"description\":\"Identify missing logs in critical paths, inconsistent log levels, PII in logs, structured logging\",\"icon\":\"logging\",\"prompt\":\"Analyze logging coverage:\\n\\n1. **Missing Logs**: Identify critical operations without logging (errors, business events)\\n2. **Log Levels**: Check for incorrect log levels (debug as info, errors as warnings)\\n3. **PII in Logs**: Find logs containing personal identifiable information\\n4. **Structured Logging**: Verify logs use structured format (JSON) not plain strings\\n5. **Correlation IDs**: Check if requests have correlation IDs for tracing\\n6. **Sensitive Data**: Ensure passwords, tokens, credit cards are not logged\\n7. **Log Volume**: Identify overly verbose logging that could impact performance\\n\\nFor each finding:\\n- Code location and issue\\n- Privacy/compliance risk\\n- Corrected logging example\",\"tags\":[\"observability\",\"logging\",\"compliance\"]},{\"id\":\"error-handling-assessment\",\"category\":\"Observability Analysis\",\"name\":\"Error Handling Assessment\",\"description\":\"Find uncaught exceptions, missing error boundaries, poor error messages, error recovery gaps\",\"icon\":\"warning\",\"prompt\":\"Assess error handling:\\n\\n1. **Uncaught Exceptions**: Find try-catch blocks missing or errors not handled\\n2. **Error Boundaries**: React apps should have error boundaries at strategic levels\\n3. **Error Messages**: Check if errors provide actionable information to users\\n4. **Error Propagation**: Verify errors bubble up correctly without being swallowed\\n5. **Retry Logic**: Identify operations that should retry on transient failures\\n6. **Graceful Degradation**: Check if system degrades gracefully vs. hard failures\\n7. **Error Monitoring**: Verify errors are sent to monitoring (Sentry, Rollbar)\\n\\nFor each gap:\\n- Code location and risk\\n- User/developer impact\\n- Proper error handling example\",\"tags\":[\"observability\",\"reliability\",\"errors\"]},{\"id\":\"monitoring-gaps-detector\",\"category\":\"Observability Analysis\",\"name\":\"Monitoring Gaps Detector\",\"description\":\"Identify missing metrics, alerting opportunities, SLO/SLI coverage, trace missing in critical flows\",\"icon\":\"monitoring\",\"prompt\":\"Detect monitoring gaps:\\n\\n1. **Missing Metrics**: Identify critical operations without metrics (latency, throughput, errors)\\n2. **Alerting**: Suggest alerts for SLO violations, error spikes, performance degradation\\n3. **SLO/SLI Coverage**: Check if key user journeys have defined SLOs\\n4. **Trace Coverage**: Verify distributed tracing covers critical flows\\n5. **Business Metrics**: Ensure business KPIs are tracked (sign-ups, conversions, revenue)\\n6. **Dashboard Gaps**: Identify missing dashboards for system health\\n7. **Anomaly Detection**: Suggest metrics that would benefit from anomaly detection\\n\\nFor each gap:\\n- What should be monitored and why\\n- Recommended metrics and thresholds\\n- Example implementation (Prometheus, DataDog, etc.)\",\"tags\":[\"observability\",\"monitoring\",\"sre\"]},{\"id\":\"framework-migration-planner\",\"category\":\"Migration Analysis\",\"name\":\"Framework Migration Planner\",\"description\":\"Analyze codebase for migration (React, Vue, Angular): breaking changes, deprecations, effort estimation\",\"icon\":\"refresh\",\"prompt\":\"Plan framework migration:\\n\\n1. **Breaking Changes**: Identify code affected by breaking changes in new version\\n2. **Deprecated APIs**: Find usage of deprecated APIs that need replacement\\n3. **New Features**: Suggest new features that could simplify existing code\\n4. **Migration Phases**: Break migration into phases (codemods, manual changes, testing)\\n5. **Effort Estimation**: Estimate person-days per phase\\n6. **Risk Assessment**: Identify high-risk areas that need extra testing\\n7. **Rollback Plan**: Suggest incremental migration strategy with rollback points\\n\\nProvide:\\n- Comprehensive migration checklist\\n- Code examples for common patterns (before/after)\\n- Recommended migration order\",\"tags\":[\"migration\",\"planning\",\"framework\"]},{\"id\":\"javascript-to-typescript\",\"category\":\"Migration Analysis\",\"name\":\"JavaScript to TypeScript\",\"description\":\"Analyze JS codebase: type inference suggestions, any type candidates, interface extraction\",\"icon\":\"typescript\",\"prompt\":\"Plan JavaScript to TypeScript migration:\\n\\n1. **Type Inference**: Suggest explicit types where inference fails\\n2. **Any Type Candidates**: Find complex types that might need 'any' initially\\n3. **Interface Extraction**: Generate interfaces from object shapes\\n4. **Utility Types**: Suggest utility types (Partial, Pick, Omit) for common patterns\\n5. **Strict Mode**: Assess readiness for strict mode flags\\n6. **Third-Party Types**: Check @types availability for dependencies\\n7. **Migration Strategy**: Suggest file-by-file vs. all-at-once approach\\n\\nProvide:\\n- Priority order for migrating files (leaf nodes first)\\n- Type definitions for core data structures\\n- tsconfig.json with appropriate strictness\",\"tags\":[\"migration\",\"typescript\",\"types\"]},{\"id\":\"change-impact-analysis\",\"category\":\"Migration Analysis\",\"name\":\"Change Impact Analysis\",\"description\":\"Analyze proposed change impact: affected modules, breaking changes, required updates, rollback strategy\",\"icon\":\"target\",\"prompt\":\"Analyze impact of proposed change:\\n\\n1. **Affected Modules**: Identify all modules that depend on changed code\\n2. **Breaking Changes**: Detect if change breaks existing contracts/APIs\\n3. **Required Updates**: List all locations that need updates\\n4. **Test Coverage**: Check if affected code has tests\\n5. **Rollback Strategy**: Assess how easily change can be rolled back\\n6. **Performance Impact**: Estimate performance implications\\n7. **Migration Path**: For breaking changes, suggest migration steps\\n\\nProvide:\\n- Blast radius (how many files/modules affected)\\n- Risk level (low/medium/high)\\n- Recommended rollout strategy (feature flag, canary, etc.)\",\"tags\":[\"analysis\",\"impact\",\"planning\"]},{\"id\":\"accessibility-audit-wcag\",\"category\":\"UX/Accessibility Analysis\",\"name\":\"Accessibility Audit (WCAG)\",\"description\":\"Review for WCAG 2.1 AA: ARIA labels, keyboard navigation, color contrast, screen reader support\",\"icon\":\"accessibility\",\"prompt\":\"Audit accessibility compliance (WCAG 2.1 AA):\\n\\n1. **ARIA Labels**: Check interactive elements have proper labels\\n2. **Keyboard Navigation**: Verify all functionality accessible via keyboard\\n3. **Color Contrast**: Test text/background contrast meets 4.5:1 ratio\\n4. **Screen Reader Support**: Ensure semantic HTML and ARIA for screen readers\\n5. **Focus Management**: Check visible focus indicators and logical tab order\\n6. **Form Accessibility**: Labels, error messages, required field indicators\\n7. **Image Alt Text**: Verify images have descriptive alt text\\n\\nFor each violation:\\n- WCAG criterion (e.g., 1.1.1, 2.1.1)\\n- User impact (blind, low vision, keyboard-only users)\\n- Remediation with code example\",\"tags\":[\"accessibility\",\"ux\",\"compliance\"]},{\"id\":\"mobile-responsiveness-check\",\"category\":\"UX/Accessibility Analysis\",\"name\":\"Mobile Responsiveness Check\",\"description\":\"Analyze responsive design: breakpoint coverage, touch targets, viewport config, mobile-specific UX\",\"icon\":\"mobile\",\"prompt\":\"Audit mobile responsiveness:\\n\\n1. **Breakpoint Coverage**: Check layout works at common breakpoints (320px, 375px, 768px, 1024px)\\n2. **Touch Targets**: Verify buttons/links are at least 44×44px\\n3. **Viewport Meta Tag**: Ensure proper viewport configuration\\n4. **Mobile-Specific UX**: Check for mobile hamburger menu, swipe gestures\\n5. **Font Sizing**: Text should scale appropriately, avoid fixed pixel sizes\\n6. **Horizontal Scrolling**: Ensure no horizontal scroll on small screens\\n7. **Performance**: Check if images are responsive, lazy loaded\\n\\nFor each issue:\\n- Breakpoint and specific problem\\n- User experience impact\\n- Responsive CSS fix\",\"tags\":[\"mobile\",\"responsive\",\"ux\"]},{\"id\":\"user-journey-analysis\",\"category\":\"UX/Accessibility Analysis\",\"name\":\"User Journey Analysis\",\"description\":\"Map user flows, identify friction points, dead ends, confusing navigation, conversion blockers\",\"icon\":\"map\",\"prompt\":\"Analyze user journeys:\\n\\n1. **Flow Mapping**: Map out key user journeys (sign-up, purchase, onboarding)\\n2. **Friction Points**: Identify steps that cause user confusion or drop-off\\n3. **Dead Ends**: Find pages with no clear next action\\n4. **Navigation Issues**: Detect confusing or inconsistent navigation\\n5. **Form Complexity**: Assess if forms are too long or complex\\n6. **Error Prevention**: Check if system prevents errors vs. just showing them\\n7. **Conversion Blockers**: Identify UX issues preventing goal completion\\n\\nFor each journey:\\n- Current flow diagram\\n- Identified friction points with severity\\n- Recommended improvements\",\"tags\":[\"ux\",\"conversion\",\"user-flow\"]},{\"id\":\"api-design-consistency\",\"category\":\"Consistency Analysis\",\"name\":\"API Design Consistency\",\"description\":\"Review REST/GraphQL consistency: naming conventions, HTTP verbs, response structures, error formats\",\"icon\":\"link\",\"prompt\":\"Audit API design consistency:\\n\\n1. **Naming Conventions**: Check consistent resource naming (plural/singular, camelCase/snake_case)\\n2. **HTTP Verbs**: Verify proper use of GET/POST/PUT/PATCH/DELETE\\n3. **Response Structures**: Ensure consistent shape ({ data, error, meta })\\n4. **Error Formats**: Check error responses follow same format (code, message, details)\\n5. **Status Codes**: Verify appropriate status codes (200, 201, 400, 404, 500)\\n6. **Pagination**: Consistent pagination (cursor vs. offset, parameter names)\\n7. **Versioning**: Check API versioning strategy (URL vs. header)\\n\\nFor each inconsistency:\\n- Endpoints affected\\n- Current vs. recommended pattern\\n- Migration guide if breaking change needed\",\"tags\":[\"api\",\"consistency\",\"design\"]},{\"id\":\"code-style-inconsistencies\",\"category\":\"Consistency Analysis\",\"name\":\"Code Style Inconsistencies\",\"description\":\"Find pattern violations: naming conventions, file structure, import order, component patterns\",\"icon\":\"palette\",\"prompt\":\"Detect code style inconsistencies:\\n\\n1. **Naming Conventions**: Find violations (camelCase, PascalCase, SCREAMING_SNAKE_CASE)\\n2. **File Structure**: Check if files are organized consistently\\n3. **Import Order**: Verify consistent import sorting (stdlib, external, internal)\\n4. **Component Patterns**: Check consistent component structure (hooks order, prop types)\\n5. **State Management**: Ensure consistent state management approach\\n6. **Error Handling**: Verify consistent error handling pattern\\n7. **Code Formatting**: Check for formatting inconsistencies\\n\\nFor each inconsistency:\\n- File location and pattern\\n- Correct pattern based on project conventions\\n- Autofix suggestions (eslint, prettier rules)\",\"tags\":[\"consistency\",\"style\",\"quality\"]},{\"id\":\"spring-boot-best-practices\",\"category\":\"Java/Spring Boot\",\"name\":\"Spring Boot Best Practices\",\"description\":\"Audit Spring Boot app: proper annotations, dependency injection, configuration, exception handling\",\"icon\":\"leaf\",\"prompt\":\"Audit Spring Boot best practices:\\n\\n1. **Annotation Usage**: Check proper use of @Service, @Repository, @Component, @Controller\\n2. **Dependency Injection**: Prefer constructor injection over field injection\\n3. **Configuration Properties**: Use @ConfigurationProperties instead of @Value for complex config\\n4. **Exception Handling**: Verify @ControllerAdvice for global exception handling\\n5. **Transaction Management**: Check @Transactional usage and propagation settings\\n6. **Bean Scope**: Verify appropriate bean scopes (singleton, prototype, request)\\n7. **Spring Data**: Check proper repository method naming, custom queries, pagination\\n\\nFor each issue:\\n- Anti-pattern detected\\n- Why it's problematic (testability, maintainability, performance)\\n- Best practice implementation\",\"tags\":[\"java\",\"spring-boot\",\"best-practices\"]},{\"id\":\"jpa-hibernate-optimization\",\"category\":\"Java/Spring Boot\",\"name\":\"JPA/Hibernate Optimization\",\"description\":\"Analyze JPA usage: N+1 queries, lazy loading, fetch strategies, entity relationships, caching\",\"icon\":\"save\",\"prompt\":\"Optimize JPA/Hibernate usage:\\n\\n1. **N+1 Query Detection**: Find @OneToMany/@ManyToOne causing N+1 queries (use JOIN FETCH)\\n2. **Lazy Loading Issues**: Check LazyInitializationException risks (use @Transactional correctly)\\n3. **Fetch Strategies**: Verify EAGER vs LAZY fetch is appropriate\\n4. **Entity Relationships**: Review bidirectional relationships, orphan removal, cascade types\\n5. **Query Optimization**: Check for SELECT * (use DTO projections), pagination\\n6. **Second-Level Cache**: Suggest entities that would benefit from caching (@Cacheable)\\n7. **Batch Processing**: Find loops saving entities individually (use batch inserts)\\n\\nFor each issue:\\n- Entity/repository location\\n- Performance impact (query count, load time)\\n- Optimized code with @EntityGraph, @Query, or DTO projection\",\"tags\":[\"java\",\"jpa\",\"hibernate\",\"performance\"]},{\"id\":\"java-concurrency-review\",\"category\":\"Java/Spring Boot\",\"name\":\"Java Concurrency Review\",\"description\":\"Audit thread safety: shared mutable state, synchronization issues, race conditions, deadlocks\",\"icon\":\"shuffle\",\"prompt\":\"Review Java concurrency and thread safety:\\n\\n1. **Shared Mutable State**: Find fields accessed by multiple threads without synchronization\\n2. **Synchronization Issues**: Check improper use of synchronized blocks/methods\\n3. **Race Conditions**: Identify check-then-act patterns without atomicity\\n4. **Deadlock Potential**: Find circular lock dependencies\\n5. **Volatile Usage**: Check if volatile is needed for visibility guarantees\\n6. **Thread-Safe Collections**: Verify use of ConcurrentHashMap vs HashMap in multi-threaded context\\n7. **CompletableFuture**: Review async code for proper error handling and composition\\n\\nFor each issue:\\n- Thread safety violation type\\n- Potential consequences (data corruption, deadlock, etc.)\\n- Thread-safe alternative (synchronized, locks, atomic classes, concurrent collections)\",\"tags\":[\"java\",\"concurrency\",\"thread-safety\"]},{\"id\":\"java-exception-handling\",\"category\":\"Java/Spring Boot\",\"name\":\"Java Exception Handling\",\"description\":\"Review exception handling: checked vs unchecked, exception swallowing, resource cleanup, custom exceptions\",\"icon\":\"zap\",\"prompt\":\"Audit Java exception handling:\\n\\n1. **Exception Swallowing**: Find empty catch blocks or catching Exception/Throwable\\n2. **Checked Exception Overuse**: Suggest converting to unchecked for runtime errors\\n3. **Resource Cleanup**: Check try-with-resources usage vs. manual finally blocks\\n4. **Custom Exceptions**: Review if custom exceptions add value or just noise\\n5. **Exception Chaining**: Ensure exceptions preserve cause (don't lose stack traces)\\n6. **Logging**: Check exceptions are logged with proper context before rethrowing\\n7. **Spring @ControllerAdvice**: Verify REST exception handling returns proper status codes\\n\\nFor each issue:\\n- Code location and problem\\n- Impact (lost information, resource leaks, unclear errors)\\n- Improved exception handling example\",\"tags\":[\"java\",\"exceptions\",\"error-handling\"]},{\"id\":\"spring-security-audit\",\"category\":\"Java/Spring Boot\",\"name\":\"Spring Security Audit\",\"description\":\"Review Spring Security config: authentication, authorization, CSRF, CORS, session management, JWT\",\"icon\":\"lock\",\"prompt\":\"Audit Spring Security configuration:\\n\\n1. **Authentication**: Review UserDetailsService, password encoding (BCrypt), authentication providers\\n2. **Authorization**: Check @PreAuthorize/@Secured usage, role hierarchy, method security\\n3. **CSRF Protection**: Verify CSRF enabled for state-changing operations\\n4. **CORS Configuration**: Check CORS is not overly permissive (not allowAll)\\n5. **Session Management**: Review session fixation protection, concurrent session control\\n6. **JWT Implementation**: Check signature verification, expiration, refresh tokens, secure storage\\n7. **Password Policy**: Verify password complexity, expiration, history\\n\\nFor each security issue:\\n- Vulnerability type (auth bypass, CSRF, etc.)\\n- Exploitation scenario\\n- Secure configuration example\",\"tags\":[\"java\",\"spring-security\",\"security\",\"critical\"]},{\"id\":\"java-stream-api-best-practices\",\"category\":\"Java/Spring Boot\",\"name\":\"Java Stream API Best Practices\",\"description\":\"Review Stream usage: performance pitfalls, proper collectors, parallel streams, primitive streams\",\"icon\":\"activity\",\"prompt\":\"Audit Java Stream API usage:\\n\\n1. **Performance Pitfalls**: Find boxed streams where primitive streams should be used (IntStream)\\n2. **Collector Usage**: Check proper use of Collectors (toList, groupingBy, partitioningBy)\\n3. **Parallel Streams**: Verify parallel() is used appropriately (not for small datasets or blocking I/O)\\n4. **Stream Reuse**: Find attempts to reuse stream (should create new stream)\\n5. **Unnecessary Boxing**: Detect unnecessary autoboxing (use mapToInt instead of map)\\n6. **Readability**: Check overly complex stream chains that should be refactored\\n7. **Side Effects**: Find side effects in stream operations (should be avoided)\\n\\nFor each issue:\\n- Stream location and problem\\n- Performance or correctness impact\\n- Optimized stream code\",\"tags\":[\"java\",\"streams\",\"performance\"]},{\"id\":\"spring-boot-actuator-setup\",\"category\":\"Java/Spring Boot\",\"name\":\"Spring Boot Actuator Setup\",\"description\":\"Review Actuator config: enabled endpoints, security, health indicators, custom metrics, monitoring integration\",\"icon\":\"analysis\",\"prompt\":\"Audit Spring Boot Actuator configuration:\\n\\n1. **Enabled Endpoints**: Check which endpoints are exposed (health, metrics, info) via management.endpoints\\n2. **Security**: Verify sensitive endpoints (env, beans, heapdump) are secured\\n3. **Health Indicators**: Review custom health indicators for dependencies (DB, Redis, external APIs)\\n4. **Custom Metrics**: Identify business metrics that should be exposed via Micrometer\\n5. **Monitoring Integration**: Check integration with Prometheus, Grafana, DataDog, etc.\\n6. **Info Endpoint**: Verify build info, git info are exposed for version tracking\\n7. **Management Port**: Check if using separate management port for actuator (production best practice)\\n\\nFor each finding:\\n- Configuration issue or missing metric\\n- Security or observability impact\\n- Proper configuration example\",\"tags\":[\"java\",\"spring-boot\",\"actuator\",\"monitoring\"]}]";

const PRESET_OBJECTS = JSON.parse(PRESETS_DATA_JSON);

const PRESETS = PRESET_OBJECTS.map((p) => [
  p.id,
  p.category,
  p.name,
  p.description,
  p.icon,
  p.prompt,
  p.tags,
]);

export const promptCategories = Array.from(new Set(PRESETS.map(([, category]) => category))).sort((a, b) => a.localeCompare(b));

export const promptPresets = PRESETS.map(([id, category, name, description, icon, prompt, tags]) => ({
  id,
  category,
  name,
  description,
  icon,
  prompt,
  executionStrategy: EXECUTION_STRATEGY,
  tags,
}));
