# Informe v2 - Fallos TUI (Quorum AI)

## Metadatos
- Herramienta: codex
- Modelo: gpt-5
- Timestamp: 2026-01-18 22:45:12 UTC
- Insumos v1:
  - fallos-tui/v1/claude-code-opus-4-5-20260118T143022-v1.md
  - fallos-tui/v1/codex-gpt-5-20260118-231950-v1.md
- Imagenes referenciadas en v1: img.png, img_1.png, img_2.png
- Entorno declarado: Go TUI (Bubble Tea + Lip Gloss + Glamour)

## Criterio de analisis (ultracritico)
- Solo se acepta como causa lo que esta respaldado por codigo del repo o fuentes oficiales.
- Todo lo no demostrable se marca como NO CONFIRMADO.
- No se incluye plan ni implementacion.

## Fuentes oficiales (resumen)
- Glamour: TermRenderer, WithAutoStyle, WithWordWrap y comportamiento de estilos. Ver pkg.go.dev (glamour) para opciones oficiales.
- Lip Gloss: Width/Size ignoran ANSI y miden celdas; Width de Style fija ancho antes de margenes. Ver pkg.go.dev (lipgloss).
- Bubble Tea: WindowSizeMsg se emite al inicio y en cada resize. Ver pkg.go.dev (bubbletea).

## Evidencia directa en codigo (verificado)
A continuacion se consolidan los hallazgos confirmados. Cada punto incluye evidencia en archivos del repo o mod cache.

### 1) Contador de tokens: in/out forzados a iguales (ERROR FUNCIONAL)
**Evidencia (codigo):**
- `internal/tui/chat/model.go` en `renderHeader` suma tokens de agentes y luego reparte `m.totalTokens` a mitades: `tokensIn += m.totalTokens / 2` y `tokensOut += m.totalTokens / 2`.
- `m.totalTokens` se calcula como suma de in+out en `WorkflowCompletedMsg` (`TotalTokensIn + TotalTokensOut`).

**Consecuencia validada:**
- Si solo hay tokens de workflow (o si los tokens por agente son 0), el header fuerza in==out. Eso contradice la metrica real si in/out son distintos.

**Impacto:**
- Metrica de consumo incorrecta; afecta costos y diagnostico de truncado.

### 2) Inconsistencia entre header de tokens y panel de logs (ERROR DE COHERENCIA)
**Evidencia (codigo):**
- Header usa `m.totalTokens` (workflow) + sumas por agente.
- LogsPanel usa solo `agentInfos` via `updateLogsPanelTokenStats()`; no agrega `m.totalTokens`.

**Consecuencia validada:**
- El total del header puede mostrar tokens que el panel de logs nunca refleja. Inconsistencia en la misma pantalla.

### 3) Dropdown de comandos: no es overlay, altera el layout (ERROR DE UX/REQUISITO)
**Evidencia (codigo):**
- `renderInlineSuggestions` se inserta en `renderMainContent` despues del input.
- `recalculateLayout` suma `suggestionsHeight` a `fixedHeight` y reduce el viewport.
- Comentario en `View`: “Autocomplete suggestions are now rendered inline in renderMainContent, not as overlay”.

**Consecuencia validada:**
- Al abrir `/`, la UI cambia alturas (no overlay). Si el requisito es overlay, el comportamiento actual lo incumple.

### 4) Dropdown de comandos: calculo de ancho y truncado incoherente (ERROR VISUAL)
**Evidencia (codigo):**
- `dropdownWidth` se clampa a [40..70].
- `maxDescWidth` se calcula con `width` (ancho del panel principal), no con `dropdownWidth`.
- La cabecera “Commands” va fuera del box (`headerLine + "\n" + boxStyle.Render(content)`).

**Consecuencia validada:**
- Descripciones pueden exceder el box cuando `width` > `dropdownWidth`, tocando o cruzando el borde.
- La cabecera no comparte el mismo ancho/padding del box, generando desalineacion.

### 5) Dropdown: highlight solo en columna de comando (NO CUBRE DESCRIPCION)
**Evidencia (codigo):**
- El estilo seleccionado aplica solo a `" ▸ "+paddedCmd`.
- La descripcion se renderiza con `descStyle` sin background.

**Consecuencia validada:**
- Si el UX requiere highlight de fila completa, el comportamiento actual no lo cumple.

### 6) Inline code con bloque extra al final: explicado por estilo Glamour (NO ES BUG DE ANSI)
**Evidencia (codigo de modulo):**
- `/home/hugolma/go/pkg/mod/github.com/charmbracelet/glamour@v0.10.0/styles/dark.json` define `code` con `prefix` y `suffix` como espacio, y `background_color`.
- El renderer usa `glamour.WithAutoStyle()` y `glamour.WithWordWrap(80)`; si el estilo activo incluye prefijo/sufijo, esos espacios se pintan con background.
- En `renderHistory`, el markdown renderizado se usa tal cual (solo `TrimSpace` global), por lo que el `suffix` queda visible si el inline code termina linea.

**Consecuencia validada:**
- El “bloque fantasma” tras inline code es consistente con el estilo por defecto (espacio con background). No es evidencia de escape ANSI sin cerrar.

### 7) Shortcuts overlay: subrayados fijos y centrado inconsistente (ERROR VISUAL)
**Evidencia (codigo):**
- Subrayado fijo: `strings.Repeat("─", 20)` (ancho constante, no dinamico).
- Centrado de titulo/footers usa `s.width`, mientras que el box usa `Width(s.width-4)` y `Padding(1,2)`.

**Consecuencia validada:**
- Subrayados no coinciden con ancho real de la columna.
- Centrado y padding pueden quedar desfasados respecto al box.

### 8) Focus mode existe y esta cableado (REQUISITO PENDIENTE)
**Evidencia (codigo):**
- `F11` alterna `m.focusMode` y oculta sidebars (`showLogs`, `showExplorer`).
- Shortcuts overlay lista `F11 Focus/Zen mode`.

**Consecuencia validada:**
- Si el requisito es eliminarlo, el estado actual no cumple.

### 9) Hint `^5 stats` existe pero no hay binding (ERROR DE CONSISTENCIA)
**Evidencia (codigo):**
- `renderFooter` muestra `^5 stats`.
- No hay caso `Ctrl+5` en `handleKeyMsg`.
- `LogsPanel.ToggleFooter()` existe pero no se invoca.

**Consecuencia validada:**
- La UI sugiere una accion que no esta implementada.

### 10) Desfase entre recalculateLayout y View (Riesgo de desbordes)
**Evidencia (codigo):**
- `recalculateLayout`: `availableWidth := m.width - 2`.
- `View`: `mainWidth := w` sin restar 2.

**Consecuencia validada:**
- El viewport se calcula con un ancho distinto al usado para renderizar el main panel. Esto genera off-by-2 y puede producir recortes o columnas vacias, segun tamano de terminal.

### 11) Overflow garantizado en terminales estrechas (RIESGO DE BORDE DERECHO PERDIDO)
**Evidencia (codigo):**
- `mainWidth` se clampa a minimo 40 despues de restar sidebars.
- Con ambos sidebars: `total = explorer + logs + main + separadores`.

**Consecuencia validada:**
- Para anchos menores a ~107 columnas (con minimos de sidebars), la suma excede el ancho disponible y el borde derecho puede quedar fuera de pantalla.

### 12) Uso de `len()` en calculos de ancho (RIESGO CON UNICODE)
**Evidencia (codigo):**
- `renderInlineSuggestions`: `cmdLen := len(...)`, truncado de `desc` con `len`.
- `calculateInputLines`: calcula wraps con `len(line)`.
- `ExplorerPanel.formatEntry`: truncado por slicing `name[:maxNameLen-3]`.

**Consecuencia validada:**
- Con caracteres de ancho variable (CJK, emoji), los calculos de ancho y truncado son incorrectos, provocando desalineacion o cortes ilegales de bytes.

### 13) WordWrap fijo a 80 para markdown (DESALINEACION POTENCIAL)
**Evidencia (codigo):**
- `glamour.WithWordWrap(80)` es fijo y no depende del ancho del panel.

**Consecuencia validada:**
- El markdown puede romper lineas antes o despues de lo esperado respecto al ancho real del viewport, creando columnas irregulares y gaps.

## Hallazgos de v1 NO respaldados por codigo (marcados como NO CONFIRMADO)
Estos puntos aparecen en v1 pero no se sustentan en el codigo actual; requieren reproduccion real o revision de imagenes.

1) “Fondos desfasados” en titulos de secciones del overlay de shortcuts.
   - En `shortcuts.go` los titulos no tienen background. No hay base para un bloque magenta detras del texto.

2) “Bloque fantasma” junto a titulo “Shortcuts”.
   - `titleStyle` no define background; no hay evidencia de bloque coloreado.

3) “Separador tok: 295-295 usa guion de ancho distinto”.
   - El header usa `in->out` con flecha (no guion). Si se ve un guion, no coincide con este commit.

4) “Indicador i 10 more commands below”.
   - El codigo imprime `up/down` con flechas, no una letra `i`.

5) “Explorer desaparece al abrir /”.
   - No hay ninguna logica que cambie `showExplorer` al abrir suggestions. Si ocurre, seria overflow o focus mode, no un toggle explicito.

6) “Bordes de sidebar derecho truncados siempre”.
   - El overflow es reproducible en terminales estrechas, pero no se deduce que sea siempre. Se requiere reproduccion con dimensiones reales.

7) “Artefacto de z-index en key badges (background corrido)”.
   - El render aplica background solo al label de tecla y luego texto. El offset descrito no aparece en el codigo por si mismo.

## Puntos de v1 que se corrigen o refinan
- “Len vs runewidth como causa global”: falso como generalizacion. El codigo ya usa `lipgloss.Width` en muchas partes, pero persisten usos puntuales de `len` (ver hallazgo 12).
- “Secuencias ANSI no cerradas”: no hay evidencia. Lip Gloss maneja resets; los bloques de inline code se explican por el estilo de Glamour.
- “WindowSizeMsg no se propaga”: el modelo recalcula layout en `WindowSizeMsg` y ajusta sizes de paneles. No hay evidencia de que falte propagacion.

## Nuevas ideas (basadas en codigo, no especulativas)
1) Unificar el calculo de widths en una sola fuente (recalculateLayout vs View) para evitar off-by-2.
2) Ajustar `WithWordWrap` al ancho real del viewport en cada resize, o desactivar wordwrap fijo.
3) Usar `lipgloss.Width` o `runewidth` en todos los calculos y truncados (input, explorer, dropdown).
4) Eliminar la cabecera fuera del box en dropdown, o ajustar su ancho al box.
5) Si el UX quiere highlight de fila completa, aplicar background al string completo de cada linea, no solo al label.

## Mapa de codigo (referencias concretas)
- Tokens header: `internal/tui/chat/model.go` (renderHeader).
- Tokens workflow total: `internal/tui/chat/model.go` (WorkflowCompletedMsg).
- Logs tokens: `internal/tui/chat/logs.go` (renderFooter) + `updateLogsPanelTokenStats`.
- Dropdown comandos: `internal/tui/chat/model.go` (renderInlineSuggestions, recalculateLayout, renderMainContent).
- Focus mode / F11: `internal/tui/chat/model.go` (handleKeyMsg) + `internal/tui/chat/shortcuts.go`.
- Shortcuts overlay: `internal/tui/chat/shortcuts.go` (Render).
- Explorer truncado por bytes: `internal/tui/chat/explorer.go` (formatEntry).
- Glamour inline code style: `/home/hugolma/go/pkg/mod/github.com/charmbracelet/glamour@v0.10.0/styles/dark.json`.

## Conclusion consolidada
Los problemas mas solidos y medibles no son “misterios de ANSI”, sino decisiones especificas de layout y estilos: token stats repartidos a mitades, dropdown inline con calculos de ancho inconsistentes, uso de wordwrap fijo y truncados por bytes, y mismatch entre layout y view. Los artefactos de inline code se explican por el estilo por defecto de Glamour (prefijo/sufijo con background). Varias observaciones de v1 (fondos desfasados en shortcuts, guiones en tokens, indicador con letra i, desaparicion del explorer) no estan sustentadas por el codigo actual y deben considerarse NO CONFIRMADAS hasta reproducir.
