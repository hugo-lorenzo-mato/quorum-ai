package workflow

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/hugo-lorenzo-mato/quorum-ai/internal/core"
	"github.com/hugo-lorenzo-mato/quorum-ai/internal/logging"
)

// =============================================================================
// Tests for workflow_isolation_finalize.go
// =============================================================================

func TestBuildWorkflowPRBody(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		state    *core.WorkflowState
		contains []string
	}{
		{
			name: "basic state with tasks",
			state: &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{
					WorkflowID: "wf-test-123",
					Prompt:     "Implement feature X",
				},
				WorkflowRun: core.WorkflowRun{
					Tasks: map[core.TaskID]*core.TaskState{
						"task-1": {ID: "task-1", Name: "Setup"},
						"task-2": {ID: "task-2", Name: "Implement"},
					},
					TaskOrder: []core.TaskID{"task-1", "task-2"},
				},
			},
			contains: []string{
				"## Prompt", "Implement feature X",
				"## Tasks", "Setup", "Implement",
				"wf-test-123", "Generated by quorum-ai",
			},
		},
		{
			name: "empty tasks",
			state: &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{
					WorkflowID: "wf-empty",
					Prompt:     "Test prompt",
				},
				WorkflowRun: core.WorkflowRun{
					Tasks:     map[core.TaskID]*core.TaskState{},
					TaskOrder: []core.TaskID{},
				},
			},
			contains: []string{"## Prompt", "Test prompt", "wf-empty"},
		},
		{
			name: "nil task in map",
			state: &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{
					WorkflowID: "wf-nil",
					Prompt:     "Nil task test",
				},
				WorkflowRun: core.WorkflowRun{
					Tasks: map[core.TaskID]*core.TaskState{
						"task-1": nil,
					},
					TaskOrder: []core.TaskID{"task-1"},
				},
			},
			contains: []string{"## Prompt", "wf-nil"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			body := buildWorkflowPRBody(tt.state)
			for _, s := range tt.contains {
				if !strings.Contains(body, s) {
					t.Errorf("buildWorkflowPRBody() missing expected string %q in:\n%s", s, body)
				}
			}
		})
	}
}

func TestWorkflowIsolationFinalizer_LogWarn(t *testing.T) {
	t.Parallel()

	// nil logger should not panic
	f := &WorkflowIsolationFinalizer{Logger: nil}
	f.logWarn("test warning", "key", "value") // should not panic

	// with logger
	f2 := &WorkflowIsolationFinalizer{Logger: logging.NewNop()}
	f2.logWarn("test warning", "key", "value")

	// nil finalizer
	var f3 *WorkflowIsolationFinalizer
	f3.logWarn("test") // should not panic
}

func TestWorkflowIsolationFinalizer_LogInfo(t *testing.T) {
	t.Parallel()

	// nil logger should not panic
	f := &WorkflowIsolationFinalizer{Logger: nil}
	f.logInfo("test info", "key", "value")

	// with logger
	f2 := &WorkflowIsolationFinalizer{Logger: logging.NewNop()}
	f2.logInfo("test info", "key", "value")

	// nil finalizer
	var f3 *WorkflowIsolationFinalizer
	f3.logInfo("test")
}

func TestWorkflowIsolationFinalizer_Finalize_NilGuards(t *testing.T) {
	t.Parallel()

	// nil finalizer
	var f1 *WorkflowIsolationFinalizer
	f1.Finalize(context.Background(), &core.WorkflowState{})

	// nil state
	f2 := &WorkflowIsolationFinalizer{}
	f2.Finalize(context.Background(), nil)

	// nil git isolation
	f3 := &WorkflowIsolationFinalizer{GitIsolation: nil}
	f3.Finalize(context.Background(), &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
		WorkflowRun:        core.WorkflowRun{WorkflowBranch: "wf/wf-1"},
	})

	// disabled git isolation
	f4 := &WorkflowIsolationFinalizer{GitIsolation: &GitIsolationConfig{Enabled: false}}
	f4.Finalize(context.Background(), &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
		WorkflowRun:        core.WorkflowRun{WorkflowBranch: "wf/wf-1"},
	})

	// nil worktree manager
	f5 := &WorkflowIsolationFinalizer{
		GitIsolation:      &GitIsolationConfig{Enabled: true},
		WorkflowWorktrees: nil,
	}
	f5.Finalize(context.Background(), &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
		WorkflowRun:        core.WorkflowRun{WorkflowBranch: "wf/wf-1"},
	})

	// empty workflow branch
	f6 := &WorkflowIsolationFinalizer{
		GitIsolation:      &GitIsolationConfig{Enabled: true},
		WorkflowWorktrees: &mockWorkflowWorktreeManager{},
	}
	f6.Finalize(context.Background(), &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
		WorkflowRun:        core.WorkflowRun{WorkflowBranch: ""},
	})
}

func TestWorkflowIsolationFinalizer_Finalize_NoAutoPR(t *testing.T) {
	t.Parallel()

	cleaned := false
	wwtm := &mockWWTMWithCleanup{
		cleanupFn: func(ctx context.Context, workflowID string, removeBranch bool) error {
			cleaned = true
			return nil
		},
	}

	f := &WorkflowIsolationFinalizer{
		Finalization: FinalizationConfig{
			AutoPR: false,
		},
		GitIsolation:      &GitIsolationConfig{Enabled: true},
		WorkflowWorktrees: wwtm,
		Logger:            logging.NewNop(),
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-test"},
		WorkflowRun:        core.WorkflowRun{WorkflowBranch: "wf/wf-test"},
	}

	f.Finalize(context.Background(), state)

	if !cleaned {
		t.Error("Expected cleanup to be called")
	}
}

func TestWorkflowIsolationFinalizer_Finalize_AutoPR_NoGit(t *testing.T) {
	t.Parallel()

	wwtm := &mockWWTMWithCleanup{
		cleanupFn: func(ctx context.Context, workflowID string, removeBranch bool) error {
			return nil
		},
	}

	f := &WorkflowIsolationFinalizer{
		Finalization: FinalizationConfig{
			AutoPR: true,
		},
		GitIsolation:      &GitIsolationConfig{Enabled: true},
		WorkflowWorktrees: wwtm,
		Git:               nil, // no git client
		GitHub:            nil, // no github client
		Logger:            logging.NewNop(),
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-test", Prompt: "test"},
		WorkflowRun:        core.WorkflowRun{WorkflowBranch: "wf/wf-test"},
	}

	// Should not panic, just log warnings
	f.Finalize(context.Background(), state)
}

func TestFinalizeWorkflowIsolation_NilRunner(t *testing.T) {
	t.Parallel()
	var r *Runner
	// Should not panic
	r.finalizeWorkflowIsolation(context.Background(), &core.WorkflowState{})
}

func TestFinalizeWorkflowIsolation_WithRunner(t *testing.T) {
	t.Parallel()

	r := &Runner{
		config:       DefaultRunnerConfig(),
		gitIsolation: nil, // disabled
		logger:       logging.NewNop(),
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-test"},
	}

	// Should not panic even with nil isolation
	r.finalizeWorkflowIsolation(context.Background(), state)
}

// =============================================================================
// Tests for runner.go: prepareExecution, clearPlanPhaseData, ValidateModeratorConfig, etc.
// =============================================================================

func TestPrepareExecution(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name       string
		isResume   bool
		initExecID int
		hasEvents  bool
	}{
		{
			name:       "new execution clears events",
			isResume:   false,
			initExecID: 1,
			hasEvents:  true,
		},
		{
			name:       "resume keeps events",
			isResume:   true,
			initExecID: 2,
			hasEvents:  true,
		},
		{
			name:       "zero exec id increments",
			isResume:   false,
			initExecID: 0,
			hasEvents:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			state := &core.WorkflowState{
				WorkflowRun: core.WorkflowRun{
					ExecutionID: tt.initExecID,
				},
			}
			if tt.hasEvents {
				state.AgentEvents = []core.AgentEvent{{Agent: "claude", Type: "started"}}
			}

			r := &Runner{}
			r.prepareExecution(state, tt.isResume)

			if state.ExecutionID != tt.initExecID+1 {
				t.Errorf("ExecutionID = %d, want %d", state.ExecutionID, tt.initExecID+1)
			}

			if !tt.isResume && state.AgentEvents != nil {
				t.Error("Expected AgentEvents to be nil for new execution")
			}
			if tt.isResume && tt.hasEvents && len(state.AgentEvents) == 0 {
				t.Error("Expected AgentEvents to be preserved for resume")
			}
		})
	}
}

func TestClearPlanPhaseData(t *testing.T) {
	t.Parallel()

	r := &Runner{
		logger: logging.NewNop(),
	}

	state := &core.WorkflowState{
		WorkflowRun: core.WorkflowRun{
			Tasks: map[core.TaskID]*core.TaskState{
				"task-1": {ID: "task-1"},
				"task-2": {ID: "task-2"},
			},
			TaskOrder: []core.TaskID{"task-1", "task-2"},
			Checkpoints: []core.Checkpoint{
				{Phase: core.PhaseAnalyze, Type: "phase_start"},
				{Phase: core.PhaseAnalyze, Type: "phase_complete"},
				{Phase: core.PhasePlan, Type: "phase_start"},
				{Phase: core.PhasePlan, Type: "phase_complete"},
			},
			CurrentPhase: core.PhaseExecute,
			Status:       core.WorkflowStatusCompleted,
		},
	}

	r.clearPlanPhaseData(state)

	if len(state.Tasks) != 0 {
		t.Errorf("Expected tasks to be cleared, got %d", len(state.Tasks))
	}
	if state.TaskOrder != nil {
		t.Error("Expected TaskOrder to be nil")
	}
	if state.CurrentPhase != core.PhasePlan {
		t.Errorf("Expected CurrentPhase = plan, got %v", state.CurrentPhase)
	}
	if state.Status != core.WorkflowStatusRunning {
		t.Errorf("Expected Status = running, got %v", state.Status)
	}
}

func TestValidateModeratorConfig(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		agents  []string
		config  ModeratorConfig
		wantErr bool
		errMsg  string
	}{
		{
			name:    "single agent no moderator needed",
			agents:  []string{"claude"},
			config:  ModeratorConfig{},
			wantErr: false,
		},
		{
			name:    "no agents no moderator needed",
			agents:  []string{},
			config:  ModeratorConfig{},
			wantErr: false,
		},
		{
			name:    "multi-agent moderator disabled",
			agents:  []string{"claude", "gemini"},
			config:  ModeratorConfig{Enabled: false},
			wantErr: true,
			errMsg:  "moderator",
		},
		{
			name:    "moderator enabled no agent",
			agents:  []string{"claude", "gemini"},
			config:  ModeratorConfig{Enabled: true, Agent: ""},
			wantErr: true,
			errMsg:  "agent",
		},
		{
			name:    "moderator agent not available",
			agents:  []string{"claude", "gemini"},
			config:  ModeratorConfig{Enabled: true, Agent: "nonexistent"},
			wantErr: true,
			errMsg:  "not available",
		},
		{
			name:    "valid moderator config",
			agents:  []string{"claude", "gemini"},
			config:  ModeratorConfig{Enabled: true, Agent: "claude"},
			wantErr: false,
		},
		{
			name:    "moderator agent case insensitive match",
			agents:  []string{"claude", "gemini"},
			config:  ModeratorConfig{Enabled: true, Agent: "Claude"},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			registry := &mockAgentRegistry{}
			for _, name := range tt.agents {
				registry.Register(name, &mockAgent{})
			}

			r := &Runner{
				config: &RunnerConfig{
					Moderator: tt.config,
				},
				agents: registry,
			}

			err := r.ValidateModeratorConfig()
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidateModeratorConfig() error = %v, wantErr = %v", err, tt.wantErr)
			}
			if tt.wantErr && tt.errMsg != "" && err != nil {
				if !strings.Contains(strings.ToLower(err.Error()), strings.ToLower(tt.errMsg)) {
					t.Errorf("Error message should contain %q, got: %v", tt.errMsg, err)
				}
			}
		})
	}
}

func TestValidateAgentAvailability(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		agents  map[string]core.Agent
		wantErr bool
		errMsg  string
	}{
		{
			name: "all agents available",
			agents: map[string]core.Agent{
				"claude": &mockAgent{},
				"gemini": &mockAgent{},
			},
			wantErr: false,
		},
		{
			name: "single agent available",
			agents: map[string]core.Agent{
				"claude": &mockAgent{},
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			registry := &mockAgentRegistry{agents: tt.agents}
			r := &Runner{
				config: DefaultRunnerConfig(),
				agents: registry,
			}

			err := r.ValidateAgentAvailability(context.Background())
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidateAgentAvailability() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestHandleAbort(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{
		config:     DefaultRunnerConfig(),
		state:      sm,
		logger:     logging.NewNop(),
		output:     NopOutputNotifier{},
		checkpoint: &mockCheckpointCreator{},
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{
			WorkflowID: "wf-abort-test",
		},
		WorkflowRun: core.WorkflowRun{
			Status:       core.WorkflowStatusRunning,
			CurrentPhase: core.PhaseExecute,
			Tasks: map[core.TaskID]*core.TaskState{
				"task-1": {ID: "task-1", Status: core.TaskStatusRunning},
				"task-2": {ID: "task-2", Status: core.TaskStatusCompleted},
				"task-3": {ID: "task-3", Status: core.TaskStatusPending},
			},
		},
	}

	err := r.handleAbort(context.Background(), state, fmt.Errorf("cancelled"))

	if !isWorkflowCancelled(err) {
		t.Errorf("Expected cancelled error, got: %v", err)
	}

	if state.Status != core.WorkflowStatusAborted {
		t.Errorf("Expected status aborted, got %v", state.Status)
	}

	// Running task should be failed
	if state.Tasks["task-1"].Status != core.TaskStatusFailed {
		t.Errorf("Expected running task to be failed, got %v", state.Tasks["task-1"].Status)
	}
	// Completed task should stay completed
	if state.Tasks["task-2"].Status != core.TaskStatusCompleted {
		t.Errorf("Expected completed task to stay completed, got %v", state.Tasks["task-2"].Status)
	}
	// Pending task should stay pending
	if state.Tasks["task-3"].Status != core.TaskStatusPending {
		t.Errorf("Expected pending task to stay pending, got %v", state.Tasks["task-3"].Status)
	}
}

func TestHandleError(t *testing.T) {
	t.Parallel()

	tmpDir := t.TempDir()
	reportDir := filepath.Join(tmpDir, "report")

	sm := &mockStateManager{}
	r := &Runner{
		config:      DefaultRunnerConfig(),
		state:       sm,
		logger:      logging.NewNop(),
		output:      NopOutputNotifier{},
		checkpoint:  &mockCheckpointCreator{},
		projectRoot: tmpDir,
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{
			WorkflowID: "wf-error-test",
			Prompt:     "test prompt",
		},
		WorkflowRun: core.WorkflowRun{
			Status:       core.WorkflowStatusRunning,
			CurrentPhase: core.PhasePlan,
			ReportPath:   reportDir,
		},
	}

	testErr := fmt.Errorf("test error occurred")
	result := r.handleError(context.Background(), state, testErr)

	if result != testErr {
		t.Errorf("Expected original error, got: %v", result)
	}
	if state.Status != core.WorkflowStatusFailed {
		t.Errorf("Expected status failed, got %v", state.Status)
	}
	if state.Error != testErr.Error() {
		t.Errorf("Expected error message %q, got %q", testErr.Error(), state.Error)
	}

	// Check error file was written
	errorFile := filepath.Join(reportDir, "error.md")
	if _, err := os.Stat(errorFile); os.IsNotExist(err) {
		t.Error("Expected error.md to be written")
	} else {
		content, _ := os.ReadFile(errorFile)
		if !strings.Contains(string(content), "test error occurred") {
			t.Error("error.md should contain the error message")
		}
	}
}

func TestHandleError_Cancelled(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{
		config:     DefaultRunnerConfig(),
		state:      sm,
		logger:     logging.NewNop(),
		output:     NopOutputNotifier{},
		checkpoint: &mockCheckpointCreator{},
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-cancel"},
		WorkflowRun: core.WorkflowRun{
			Status:       core.WorkflowStatusRunning,
			CurrentPhase: core.PhaseAnalyze,
		},
	}

	cancelErr := workflowCancelledError()
	result := r.handleError(context.Background(), state, cancelErr)

	if !isWorkflowCancelled(result) {
		t.Error("Expected cancelled error")
	}
	if state.Status != core.WorkflowStatusAborted {
		t.Errorf("Expected aborted, got %v", state.Status)
	}
}

func TestWriteErrorToReportDir(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name       string
		reportPath string
		wantFile   bool
	}{
		{
			name:       "empty report path",
			reportPath: "",
			wantFile:   false,
		},
		{
			name:       "valid report path",
			reportPath: filepath.Join(t.TempDir(), "report"),
			wantFile:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &Runner{
				logger: logging.NewNop(),
			}

			state := &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{
					WorkflowID: "wf-test",
					Prompt:     "test prompt",
				},
				WorkflowRun: core.WorkflowRun{
					CurrentPhase: core.PhaseExecute,
					ReportPath:   tt.reportPath,
				},
			}

			r.writeErrorToReportDir(state, fmt.Errorf("test error"))

			if tt.wantFile {
				errorFile := filepath.Join(tt.reportPath, "error.md")
				if _, err := os.Stat(errorFile); os.IsNotExist(err) {
					t.Error("Expected error.md to be written")
				}
			}
		})
	}
}

// =============================================================================
// Tests for runner.go: SaveState, ListWorkflows, LoadWorkflow, etc.
// =============================================================================

func TestSaveState(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{
		config: DefaultRunnerConfig(),
		state:  sm,
	}

	state := &core.WorkflowState{
		WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-save"},
	}

	err := r.SaveState(context.Background(), state)
	if err != nil {
		t.Fatalf("SaveState() error = %v", err)
	}

	if sm.state != state {
		t.Error("State should have been saved")
	}
}

func TestListWorkflows(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{
		state: &core.WorkflowState{
			WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-list"},
			WorkflowRun: core.WorkflowRun{
				Status: core.WorkflowStatusCompleted,
			},
		},
	}

	r := &Runner{
		config: DefaultRunnerConfig(),
		state:  sm,
	}

	summaries, err := r.ListWorkflows(context.Background())
	if err != nil {
		t.Fatalf("ListWorkflows() error = %v", err)
	}

	if len(summaries) == 0 {
		t.Error("Expected at least one summary")
	}
}

func TestListWorkflows_Empty(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{
		config: DefaultRunnerConfig(),
		state:  sm,
	}

	summaries, err := r.ListWorkflows(context.Background())
	if err != nil {
		t.Fatalf("ListWorkflows() error = %v", err)
	}

	if summaries != nil {
		t.Errorf("Expected nil summaries, got %v", summaries)
	}
}

func TestLoadWorkflow(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{
		state: &core.WorkflowState{
			WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-load"},
		},
	}

	r := &Runner{
		config: DefaultRunnerConfig(),
		state:  sm,
	}

	state, err := r.LoadWorkflow(context.Background(), "wf-load")
	if err != nil {
		t.Fatalf("LoadWorkflow() error = %v", err)
	}

	if state.WorkflowID != "wf-load" {
		t.Errorf("Expected workflow ID wf-load, got %s", state.WorkflowID)
	}
}

func TestLoadWorkflow_NotFound(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{
		config: DefaultRunnerConfig(),
		state:  sm,
	}

	_, err := r.LoadWorkflow(context.Background(), "wf-nonexistent")
	if err == nil {
		t.Error("Expected error for non-existent workflow")
	}
}

func TestDeactivateWorkflow(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{config: DefaultRunnerConfig(), state: sm}

	err := r.DeactivateWorkflow(context.Background())
	if err != nil {
		t.Fatalf("DeactivateWorkflow() error = %v", err)
	}
}

func TestArchiveWorkflows(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{}
	r := &Runner{config: DefaultRunnerConfig(), state: sm}

	n, err := r.ArchiveWorkflows(context.Background())
	if err != nil {
		t.Fatalf("ArchiveWorkflows() error = %v", err)
	}
	if n != 0 {
		t.Errorf("Expected 0 archived, got %d", n)
	}
}

func TestPurgeAllWorkflows(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{
		state: &core.WorkflowState{
			WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-purge"},
		},
	}
	r := &Runner{config: DefaultRunnerConfig(), state: sm}

	n, err := r.PurgeAllWorkflows(context.Background())
	if err != nil {
		t.Fatalf("PurgeAllWorkflows() error = %v", err)
	}
	if n != 1 {
		t.Errorf("Expected 1 purged, got %d", n)
	}
}

func TestDeleteWorkflow(t *testing.T) {
	t.Parallel()

	sm := &mockStateManager{
		state: &core.WorkflowState{
			WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-delete"},
		},
	}
	r := &Runner{config: DefaultRunnerConfig(), state: sm}

	err := r.DeleteWorkflow(context.Background(), "wf-delete")
	if err != nil {
		t.Fatalf("DeleteWorkflow() error = %v", err)
	}

	// Non-existent should fail
	err = r.DeleteWorkflow(context.Background(), "wf-nonexistent")
	if err == nil {
		t.Error("Expected error for deleting non-existent workflow")
	}
}

// =============================================================================
// Tests for runner.go: ensureWorkflowGitIsolation
// =============================================================================

func TestEnsureWorkflowGitIsolation(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		config      *RunnerConfig
		isolation   *GitIsolationConfig
		wwtm        core.WorkflowWorktreeManager
		state       *core.WorkflowState
		wantChanged bool
		wantErr     bool
	}{
		{
			name:        "dry run mode",
			config:      &RunnerConfig{DryRun: true},
			isolation:   &GitIsolationConfig{Enabled: true},
			state:       &core.WorkflowState{WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"}},
			wantChanged: false,
		},
		{
			name:        "nil state",
			config:      DefaultRunnerConfig(),
			isolation:   &GitIsolationConfig{Enabled: true},
			state:       nil,
			wantChanged: false,
		},
		{
			name:        "nil isolation",
			config:      DefaultRunnerConfig(),
			isolation:   nil,
			state:       &core.WorkflowState{WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"}},
			wantChanged: false,
		},
		{
			name:        "disabled isolation",
			config:      DefaultRunnerConfig(),
			isolation:   &GitIsolationConfig{Enabled: false},
			state:       &core.WorkflowState{WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"}},
			wantChanged: false,
		},
		{
			name:        "nil worktree manager",
			config:      DefaultRunnerConfig(),
			isolation:   &GitIsolationConfig{Enabled: true},
			wwtm:        nil,
			state:       &core.WorkflowState{WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"}},
			wantChanged: false,
		},
		{
			name:      "already has workflow branch",
			config:    DefaultRunnerConfig(),
			isolation: &GitIsolationConfig{Enabled: true},
			wwtm:      &mockWorkflowWorktreeManager{},
			state: &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
				WorkflowRun:        core.WorkflowRun{WorkflowBranch: "existing-branch"},
			},
			wantChanged: false,
		},
		{
			name:      "tasks with non-pending status",
			config:    DefaultRunnerConfig(),
			isolation: &GitIsolationConfig{Enabled: true},
			wwtm:      &mockWorkflowWorktreeManager{},
			state: &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
				WorkflowRun: core.WorkflowRun{
					Tasks: map[core.TaskID]*core.TaskState{
						"task-1": {ID: "task-1", Status: core.TaskStatusCompleted},
					},
				},
			},
			wantChanged: false,
		},
		{
			name:      "tasks with git artifacts",
			config:    DefaultRunnerConfig(),
			isolation: &GitIsolationConfig{Enabled: true},
			wwtm:      &mockWorkflowWorktreeManager{},
			state: &core.WorkflowState{
				WorkflowDefinition: core.WorkflowDefinition{WorkflowID: "wf-1"},
				WorkflowRun: core.WorkflowRun{
					Tasks: map[core.TaskID]*core.TaskState{
						"task-1": {ID: "task-1", Status: core.TaskStatusPending, Branch: "some-branch"},
					},
				},
			},
			wantChanged: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &Runner{
				config:            tt.config,
				gitIsolation:      tt.isolation,
				workflowWorktrees: tt.wwtm,
				logger:            logging.NewNop(),
			}

			changed, err := r.ensureWorkflowGitIsolation(context.Background(), tt.state)
			if (err != nil) != tt.wantErr {
				t.Errorf("ensureWorkflowGitIsolation() error = %v, wantErr %v", err, tt.wantErr)
			}
			if changed != tt.wantChanged {
				t.Errorf("ensureWorkflowGitIsolation() changed = %v, want %v", changed, tt.wantChanged)
			}
		})
	}
}

// =============================================================================
// Tests for runner.go: findTasksDirectory
// =============================================================================

func TestFindTasksDirectory(t *testing.T) {
	t.Parallel()

	tmpDir := t.TempDir()

	// Create a tasks directory structure
	wfDir := filepath.Join(tmpDir, ".quorum", "runs", "wf-test-123")
	tasksDir := filepath.Join(wfDir, "plan-phase", "tasks")
	if err := os.MkdirAll(tasksDir, 0o750); err != nil {
		t.Fatal(err)
	}

	r := &Runner{
		config:      DefaultRunnerConfig(),
		projectRoot: tmpDir,
		logger:      logging.NewNop(),
	}

	dir, err := r.findTasksDirectory("wf-test-123")
	if err != nil {
		t.Fatalf("findTasksDirectory() error = %v", err)
	}

	if dir != tasksDir {
		t.Errorf("findTasksDirectory() = %q, want %q", dir, tasksDir)
	}
}

func TestFindTasksDirectory_Fallback(t *testing.T) {
	t.Parallel()

	tmpDir := t.TempDir()

	// Create the runs directory (required by ReadDir) and fallback directory
	runsDir := filepath.Join(tmpDir, ".quorum", "runs")
	if err := os.MkdirAll(runsDir, 0o750); err != nil {
		t.Fatal(err)
	}
	fallbackDir := filepath.Join(tmpDir, ".quorum", "tasks")
	if err := os.MkdirAll(fallbackDir, 0o750); err != nil {
		t.Fatal(err)
	}

	r := &Runner{
		config:      DefaultRunnerConfig(),
		projectRoot: tmpDir,
		logger:      logging.NewNop(),
	}

	dir, err := r.findTasksDirectory("wf-nonexistent")
	if err != nil {
		t.Fatalf("findTasksDirectory() error = %v", err)
	}

	if dir != fallbackDir {
		t.Errorf("findTasksDirectory() = %q, want %q", dir, fallbackDir)
	}
}

func TestFindTasksDirectory_NotFound(t *testing.T) {
	t.Parallel()

	tmpDir := t.TempDir()
	// Create the runs dir but no tasks
	if err := os.MkdirAll(filepath.Join(tmpDir, ".quorum", "runs"), 0o750); err != nil {
		t.Fatal(err)
	}

	r := &Runner{
		config:      DefaultRunnerConfig(),
		projectRoot: tmpDir,
		logger:      logging.NewNop(),
	}

	_, err := r.findTasksDirectory("wf-nonexistent")
	if err == nil {
		t.Error("Expected error for non-existent tasks directory")
	}
}

// =============================================================================
// Tests for runner.go: buildBlueprint
// =============================================================================

func TestBuildBlueprint(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name       string
		config     *RunnerConfig
		expectMode string
	}{
		{
			name: "multi agent mode",
			config: &RunnerConfig{
				SingleAgent:     SingleAgentConfig{Enabled: false},
				Moderator:       ModeratorConfig{Enabled: true, Agent: "claude"},
				Synthesizer:     SynthesizerConfig{Agent: "claude"},
				Refiner:         RefinerConfig{Enabled: true, Agent: "claude"},
				PlanSynthesizer: PlanSynthesizerConfig{Enabled: true, Agent: "claude"},
				PhaseTimeouts: PhaseTimeouts{
					Analyze: 1 * time.Hour,
					Plan:    1 * time.Hour,
					Execute: 1 * time.Hour,
				},
				MaxRetries: 3,
				Timeout:    2 * time.Hour,
				DryRun:     true,
			},
			expectMode: "multi_agent",
		},
		{
			name: "single agent mode",
			config: &RunnerConfig{
				SingleAgent: SingleAgentConfig{
					Enabled:         true,
					Agent:           "claude",
					Model:           "opus",
					ReasoningEffort: "high",
				},
			},
			expectMode: "single_agent",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			r := &Runner{config: tt.config}
			bp := r.buildBlueprint()

			if bp == nil {
				t.Fatal("buildBlueprint() returned nil")
			}
			if bp.ExecutionMode != tt.expectMode {
				t.Errorf("ExecutionMode = %q, want %q", bp.ExecutionMode, tt.expectMode)
			}
		})
	}
}

// =============================================================================
// Tests for planner_cli_tasks.go: getAgentStrengths, formatCapabilities, parseComprehensiveManifest
// =============================================================================

func TestGetAgentStrengths(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		agent    string
		contains string
	}{
		{"claude", "claude", "reasoning"},
		{"codex", "codex", "code"},
		{"gemini", "gemini", "codebase"},
		{"copilot", "copilot", "coding"},
		{"opencode", "opencode", "MCP"},
		{"unknown", "foobar", "General-purpose"},
		{"prefix match", "copilot-claude", "coding"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result := getAgentStrengths(tt.agent)
			if !strings.Contains(strings.ToLower(result), strings.ToLower(tt.contains)) {
				t.Errorf("getAgentStrengths(%q) = %q, expected to contain %q", tt.agent, result, tt.contains)
			}
		})
	}
}

func TestFormatCapabilities(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		caps     core.Capabilities
		contains []string
	}{
		{
			name:     "all capabilities",
			caps:     core.Capabilities{SupportsJSON: true, SupportsStreaming: true, SupportsTools: true, SupportsImages: true, MaxContextTokens: 200000},
			contains: []string{"JSON", "streaming", "tool", "image", "200K"},
		},
		{
			name:     "no capabilities",
			caps:     core.Capabilities{},
			contains: []string{"standard"},
		},
		{
			name:     "partial capabilities",
			caps:     core.Capabilities{SupportsJSON: true, MaxContextTokens: 128000},
			contains: []string{"JSON", "128K"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			result := formatCapabilities(tt.caps)
			for _, s := range tt.contains {
				if !strings.Contains(result, s) {
					t.Errorf("formatCapabilities() = %q, expected to contain %q", result, s)
				}
			}
		})
	}
}

func TestParseComprehensiveManifest(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		input   string
		wantErr bool
		tasks   int
	}{
		{
			name:    "valid direct JSON",
			input:   `{"tasks": [{"id": "t1", "name": "T1", "file": "/t1.md"}], "execution_levels": [["t1"]]}`,
			wantErr: false,
			tasks:   1,
		},
		{
			name: "JSON in markdown",
			input: "Here is the manifest:\n```json\n" +
				`{"tasks": [{"id": "t1", "name": "T1", "file": "/t1.md"}], "execution_levels": [["t1"]]}` +
				"\n```\nDone!",
			wantErr: false,
			tasks:   1,
		},
		{
			name:    "invalid JSON",
			input:   "not json at all",
			wantErr: true,
		},
		{
			name:    "empty tasks",
			input:   `{"tasks": [], "execution_levels": []}`,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			manifest, err := parseComprehensiveManifest(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("parseComprehensiveManifest() error = %v, wantErr %v", err, tt.wantErr)
			}
			if !tt.wantErr && manifest != nil && len(manifest.Tasks) != tt.tasks {
				t.Errorf("Expected %d tasks, got %d", tt.tasks, len(manifest.Tasks))
			}
		})
	}
}

// =============================================================================
// Tests for heartbeat.go: DefaultHeartbeatConfig, Config
// =============================================================================

func TestDefaultHeartbeatConfig(t *testing.T) {
	t.Parallel()

	cfg := DefaultHeartbeatConfig()

	if cfg.Interval != 30*time.Second {
		t.Errorf("Interval = %v, want 30s", cfg.Interval)
	}
	if cfg.StaleThreshold != 2*time.Minute {
		t.Errorf("StaleThreshold = %v, want 2m", cfg.StaleThreshold)
	}
	if cfg.CheckInterval != 60*time.Second {
		t.Errorf("CheckInterval = %v, want 60s", cfg.CheckInterval)
	}
	if cfg.AutoResume {
		t.Error("AutoResume should be false by default")
	}
	if cfg.MaxResumes != 3 {
		t.Errorf("MaxResumes = %d, want 3", cfg.MaxResumes)
	}
}

func TestHeartbeatManager_Config(t *testing.T) {
	t.Parallel()

	cfg := HeartbeatConfig{
		Interval:       10 * time.Second,
		StaleThreshold: 1 * time.Minute,
	}

	hm := NewHeartbeatManager(cfg, nil, nil)
	got := hm.Config()

	if got.Interval != cfg.Interval {
		t.Errorf("Config().Interval = %v, want %v", got.Interval, cfg.Interval)
	}
	if got.StaleThreshold != cfg.StaleThreshold {
		t.Errorf("Config().StaleThreshold = %v, want %v", got.StaleThreshold, cfg.StaleThreshold)
	}
}

// =============================================================================
// Tests for output_watchdog.go: DefaultWatchdogConfig
// =============================================================================

func TestDefaultWatchdogConfig(t *testing.T) {
	t.Parallel()

	cfg := DefaultWatchdogConfig()

	if cfg.PollInterval != 5*time.Second {
		t.Errorf("PollInterval = %v, want 5s", cfg.PollInterval)
	}
	if cfg.StabilityWindow != 60*time.Second {
		t.Errorf("StabilityWindow = %v, want 60s", cfg.StabilityWindow)
	}
	if cfg.MinFileSize != 512 {
		t.Errorf("MinFileSize = %d, want 512", cfg.MinFileSize)
	}
}

// =============================================================================
// Tests for recovery.go: FindZombieWorkflows, resetRunningTasks (already covered), SetStaleThreshold
// =============================================================================

func TestRecoveryManager_FindZombieWorkflows(t *testing.T) {
	t.Parallel()

	rm := NewRecoveryManager(&mockRecoveryStateManager{}, "/tmp", logging.NewNop())
	zombies, err := rm.FindZombieWorkflows(context.Background())
	if err != nil {
		t.Fatalf("FindZombieWorkflows() error = %v", err)
	}
	if zombies != nil {
		t.Errorf("Expected nil zombies, got %v", zombies)
	}
}

type mockRecoveryStateManager struct{}

func (m *mockRecoveryStateManager) LoadByID(_ context.Context, _ core.WorkflowID) (*core.WorkflowState, error) {
	return nil, nil
}

func (m *mockRecoveryStateManager) Save(_ context.Context, _ *core.WorkflowState) error {
	return nil
}

func (m *mockRecoveryStateManager) FindZombieWorkflows(_ context.Context, _ time.Duration) ([]*core.WorkflowState, error) {
	return nil, nil
}

// =============================================================================
// Tests for planner.go: writeExecutionGraph, writeTaskReports (need report mock)
// =============================================================================

func TestPlanner_RebuildDAGFromState_NilTasks(t *testing.T) {
	t.Parallel()

	dag := &mockDAGBuilder{}
	saver := &mockStateSaver{}
	planner := NewPlanner(dag, saver)

	state := &core.WorkflowState{
		WorkflowRun: core.WorkflowRun{
			Tasks: map[core.TaskID]*core.TaskState{},
		},
	}

	err := planner.RebuildDAGFromState(state)
	if err == nil {
		t.Error("Expected error for empty tasks")
	}
}

// =============================================================================
// Tests for planner_cli_tasks.go: collectAgentInfo
// =============================================================================

func TestCollectAgentInfo(t *testing.T) {
	t.Parallel()

	registry := &mockAgentRegistry{
		agents: map[string]core.Agent{
			"claude": &mockAgent{result: &core.ExecuteResult{}},
			"gemini": &mockAgent{result: &core.ExecuteResult{}},
		},
	}

	dag := &mockDAGBuilder{}
	saver := &mockStateSaver{}
	planner := NewPlanner(dag, saver)

	wctx := &Context{
		Agents: registry,
		Config: &Config{
			DefaultAgent: "claude",
			AgentPhaseModels: map[string]map[string]string{
				"claude": {"execute": "opus-4"},
			},
		},
		Logger: logging.NewNop(),
	}

	agents := planner.collectAgentInfo(context.Background(), wctx)

	if len(agents) != 2 {
		t.Fatalf("Expected 2 agents, got %d", len(agents))
	}

	// Check that agent info is populated
	for _, info := range agents {
		if info.Name == "" {
			t.Error("Agent name should not be empty")
		}
		if info.Strengths == "" {
			t.Errorf("Agent %s should have strengths", info.Name)
		}
		if info.Capabilities == "" {
			t.Errorf("Agent %s should have capabilities", info.Name)
		}
	}
}

// =============================================================================
// Tests for executor.go: checkControl with non-nil control
// =============================================================================

func TestExecutor_CheckControl_NilControl(t *testing.T) {
	t.Parallel()

	e := &Executor{}
	wctx := &Context{Control: nil}

	err := e.checkControl(context.Background(), wctx)
	if err != nil {
		t.Errorf("Expected nil for nil control, got: %v", err)
	}
}

// =============================================================================
// Additional: PrependToConsolidatedAnalysis
// =============================================================================

func TestPrependToConsolidatedAnalysis(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string
		state   *core.WorkflowState
		context string
		wantErr bool
	}{
		{
			name: "no checkpoints",
			state: &core.WorkflowState{
				WorkflowRun: core.WorkflowRun{
					Checkpoints: []core.Checkpoint{},
				},
			},
			context: "extra context",
			wantErr: true,
		},
		{
			name: "valid consolidated analysis",
			state: &core.WorkflowState{
				WorkflowRun: core.WorkflowRun{
					Checkpoints: []core.Checkpoint{
						{
							Type: "consolidated_analysis",
							Data: []byte(`{"content": "original analysis"}`),
						},
					},
				},
			},
			context: "additional context",
			wantErr: false,
		},
		{
			name: "invalid data in checkpoint",
			state: &core.WorkflowState{
				WorkflowRun: core.WorkflowRun{
					Checkpoints: []core.Checkpoint{
						{
							Type: "consolidated_analysis",
							Data: []byte(`not valid json`),
						},
					},
				},
			},
			context: "extra",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			err := PrependToConsolidatedAnalysis(tt.state, tt.context)
			if (err != nil) != tt.wantErr {
				t.Errorf("PrependToConsolidatedAnalysis() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

// =============================================================================
// Mock helpers specific to this file
// =============================================================================

// mockWWTMWithCleanup implements core.WorkflowWorktreeManager for testing
// with configurable cleanup behavior.
type mockWWTMWithCleanup struct {
	cleanupFn func(ctx context.Context, workflowID string, removeBranch bool) error
}

func (m *mockWWTMWithCleanup) InitializeWorkflow(_ context.Context, workflowID string, baseBranch string) (*core.WorkflowGitInfo, error) {
	return &core.WorkflowGitInfo{WorkflowID: workflowID, WorkflowBranch: "quorum/" + workflowID, BaseBranch: baseBranch}, nil
}

func (m *mockWWTMWithCleanup) FinalizeWorkflow(_ context.Context, _ string, _ bool) error {
	return nil
}

func (m *mockWWTMWithCleanup) CreateTaskWorktree(_ context.Context, _ string, _ *core.Task) (*core.WorktreeInfo, error) {
	return &core.WorktreeInfo{Path: "/tmp/wt", Branch: "task-branch"}, nil
}

func (m *mockWWTMWithCleanup) RemoveTaskWorktree(_ context.Context, _ string, _ core.TaskID, _ bool) error {
	return nil
}

func (m *mockWWTMWithCleanup) MergeTaskToWorkflow(_ context.Context, _ string, _ core.TaskID, _ string) error {
	return nil
}

func (m *mockWWTMWithCleanup) MergeAllTasksToWorkflow(_ context.Context, _ string, _ []core.TaskID, _ string) error {
	return nil
}

func (m *mockWWTMWithCleanup) CleanupWorkflow(ctx context.Context, workflowID string, removeBranch bool) error {
	if m.cleanupFn != nil {
		return m.cleanupFn(ctx, workflowID, removeBranch)
	}
	return nil
}

func (m *mockWWTMWithCleanup) GetWorkflowStatus(_ context.Context, _ string) (*core.WorkflowGitStatus, error) {
	return &core.WorkflowGitStatus{}, nil
}

func (m *mockWWTMWithCleanup) ListActiveWorkflows(_ context.Context) ([]*core.WorkflowGitInfo, error) {
	return nil, nil
}

func (m *mockWWTMWithCleanup) GetWorkflowBranch(workflowID string) string {
	return "quorum/" + workflowID
}

func (m *mockWWTMWithCleanup) GetTaskBranch(workflowID string, taskID core.TaskID) string {
	return "quorum/" + workflowID + "/" + string(taskID)
}
