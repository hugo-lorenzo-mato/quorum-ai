package workflow

import (
	"context"
	"fmt"
	"strings"

	"github.com/hugo-lorenzo-mato/quorum-ai/internal/core"
)

// TaskFinalizer handles post-task operations: commit, push, and PR creation.
type TaskFinalizer struct {
	git    core.GitClient
	github core.GitHubClient
	config FinalizationConfig
}

// NewTaskFinalizer creates a new task finalizer.
func NewTaskFinalizer(git core.GitClient, github core.GitHubClient, config FinalizationConfig) *TaskFinalizer {
	// Apply defaults
	if config.MergeStrategy == "" {
		config.MergeStrategy = "squash"
	}
	if config.Remote == "" {
		config.Remote = "origin"
	}
	return &TaskFinalizer{
		git:    git,
		github: github,
		config: config,
	}
}

// FinalizeResult contains the result of task finalization.
type FinalizeResult struct {
	CommitSHA string
	Pushed    bool
	PRNumber  int
	PRURL     string
	Merged    bool
}

// Finalize performs post-task operations on a worktree.
// workDir is the worktree path where the task executed.
// branch is the branch name for the task.
func (f *TaskFinalizer) Finalize(ctx context.Context, task *core.Task, _, branch string) (*FinalizeResult, error) {
	if f.git == nil {
		return nil, fmt.Errorf("git client not configured")
	}

	result := &FinalizeResult{}

	// Check if there are any changes to commit
	isClean, err := f.git.IsClean(ctx)
	if err != nil {
		return nil, fmt.Errorf("checking git status: %w", err)
	}

	if isClean {
		// No changes to commit
		return result, nil
	}

	// Step 1: Commit changes
	if f.config.AutoCommit {
		commitMsg := f.buildCommitMessage(task)
		if err := f.git.Add(ctx, "."); err != nil {
			return nil, fmt.Errorf("staging changes: %w", err)
		}
		sha, err := f.git.Commit(ctx, commitMsg)
		if err != nil {
			return nil, fmt.Errorf("committing changes: %w", err)
		}
		result.CommitSHA = sha
	}

	// Step 2: Push to remote
	if f.config.AutoPush && result.CommitSHA != "" {
		if err := f.git.Push(ctx, f.config.Remote, branch); err != nil {
			return nil, fmt.Errorf("pushing to remote: %w", err)
		}
		result.Pushed = true
	}

	// Step 3: Create PR
	if f.config.AutoPR && result.Pushed && f.github != nil {
		pr, err := f.createPR(ctx, task, branch)
		if err != nil {
			return nil, fmt.Errorf("creating PR: %w", err)
		}
		result.PRNumber = pr.Number
		result.PRURL = pr.HTMLURL

		// Step 4: Auto-merge if configured
		if f.config.AutoMerge {
			if err := f.mergePR(ctx, pr); err != nil {
				// Log but don't fail - PR was created successfully
				return result, fmt.Errorf("auto-merge failed (PR created): %w", err)
			}
			result.Merged = true
		}
	}

	return result, nil
}

// buildCommitMessage creates a commit message from task information.
func (f *TaskFinalizer) buildCommitMessage(task *core.Task) string {
	var b strings.Builder

	// Title: task name
	b.WriteString(fmt.Sprintf("feat(quorum): %s\n\n", task.Name))

	// Body: task description if available
	if task.Description != "" {
		b.WriteString(task.Description)
		b.WriteString("\n\n")
	}

	// Footer
	b.WriteString(fmt.Sprintf("Task-ID: %s\n", task.ID))
	b.WriteString("Generated-By: quorum-ai\n")

	return b.String()
}

// createPR creates a pull request for the task branch.
func (f *TaskFinalizer) createPR(ctx context.Context, task *core.Task, branch string) (*core.PullRequest, error) {
	baseBranch := f.config.PRBaseBranch
	if baseBranch == "" {
		// Use the default branch from the repository
		var err error
		baseBranch, err = f.github.GetDefaultBranch(ctx)
		if err != nil {
			return nil, fmt.Errorf("getting default branch: %w", err)
		}
	}

	prTitle := fmt.Sprintf("[quorum] %s", task.Name)
	prBody := f.buildPRBody(task)

	pr, err := f.github.CreatePR(ctx, core.CreatePROptions{
		Title: prTitle,
		Body:  prBody,
		Head:  branch,
		Base:  baseBranch,
	})
	if err != nil {
		return nil, err
	}

	return pr, nil
}

// buildPRBody creates the PR description from task information.
func (f *TaskFinalizer) buildPRBody(task *core.Task) string {
	var b strings.Builder

	b.WriteString("## Summary\n\n")
	b.WriteString(task.Name)
	b.WriteString("\n\n")

	if task.Description != "" {
		b.WriteString("## Description\n\n")
		b.WriteString(task.Description)
		b.WriteString("\n\n")
	}

	b.WriteString("---\n")
	b.WriteString(fmt.Sprintf("Task ID: `%s`\n", task.ID))
	b.WriteString("Generated by [quorum-ai](https://github.com/hugo-lorenzo-mato/quorum-ai)\n")

	return b.String()
}

// mergePR merges the pull request using the configured strategy.
func (f *TaskFinalizer) mergePR(ctx context.Context, pr *core.PullRequest) error {
	return f.github.MergePR(ctx, pr.Number, core.MergePROptions{
		Method:      f.config.MergeStrategy,
		CommitTitle: pr.Title,
	})
}
