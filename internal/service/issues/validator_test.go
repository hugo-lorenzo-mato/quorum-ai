package issues

import (
	"strings"
	"testing"
)

func TestValidateValidIssue(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Implement User Authentication

## Summary

This issue tracks the implementation of user authentication using JWT tokens.
The system should support login, logout, and token refresh operations.

## Acceptance Criteria

- Users can log in with email and password
- JWT tokens are issued upon successful login
- Tokens expire after 24 hours
- Users can refresh tokens before expiration

## Technical Details

The implementation will use bcrypt for password hashing and RS256 for JWT signing.
`

	result := validator.Validate(content)

	if !result.Valid {
		t.Errorf("expected valid issue, got invalid: warnings=%v", result.Warnings)
	}
	if !result.HasTitle {
		t.Error("expected HasTitle to be true")
	}
	if !result.HasBody {
		t.Error("expected HasBody to be true")
	}
	if result.ContainsForbidden {
		t.Errorf("expected no forbidden content, got: %v", result.ForbiddenMatches)
	}
}

func TestValidateInvalidIssue_NoTitle(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `## Summary

This issue has no title heading.

## Description

Some description here.
`

	result := validator.Validate(content)

	if result.Valid {
		t.Error("expected invalid issue due to missing title")
	}
	if result.HasTitle {
		t.Error("expected HasTitle to be false")
	}
}

func TestValidateInvalidIssue_NoBody(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Title Only Issue`

	result := validator.Validate(content)

	if result.Valid {
		t.Error("expected invalid issue due to missing body")
	}
	if result.HasBody {
		t.Error("expected HasBody to be false")
	}
}

func TestValidateInvalidIssue_ShortTitle(t *testing.T) {
	validator := NewIssueValidator(IssueValidatorConfig{
		MinTitleLength: 10,
		MaxTitleLength: 200,
		MinBodyLength:  10,
	})

	content := `# Hi

## Summary

This is a valid body with enough content.
`

	result := validator.Validate(content)

	if result.Valid {
		t.Error("expected invalid issue due to short title")
	}
	if result.TitleLength != 2 {
		t.Errorf("expected title length 2, got %d", result.TitleLength)
	}
}

func TestValidateIssue_ForbiddenContent_Claude(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Fix Authentication Bug

## Summary

This issue was generated by Claude to fix the authentication bug.
We need to update the login flow.
`

	result := validator.Validate(content)

	if !result.ContainsForbidden {
		t.Error("expected forbidden content to be detected (Claude)")
	}
	if len(result.ForbiddenMatches) == 0 {
		t.Error("expected at least one forbidden match")
	}

	// Check that "Claude" was matched
	found := false
	for _, match := range result.ForbiddenMatches {
		if strings.Contains(strings.ToLower(match), "claude") {
			found = true
			break
		}
	}
	if !found {
		t.Errorf("expected 'Claude' in forbidden matches, got: %v", result.ForbiddenMatches)
	}
}

func TestValidateIssue_ForbiddenContent_GPT(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Implement Feature

## Summary

This feature uses gpt-4 recommendations for implementation.
`

	result := validator.Validate(content)

	if !result.ContainsForbidden {
		t.Error("expected forbidden content to be detected (gpt-4)")
	}
}

func TestValidateIssue_ForbiddenContent_Generated(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Auto-generated Issue

## Summary

This issue was auto-generated from the analysis report.
Generated by the workflow system.
`

	result := validator.Validate(content)

	if !result.ContainsForbidden {
		t.Error("expected forbidden content to be detected (generated)")
	}
}

func TestValidateIssue_ForbiddenContent_Timestamp(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Fix Date Bug

## Summary

This issue was created at 2024-01-15T10:30:45 to track the date bug.
`

	result := validator.Validate(content)

	if !result.ContainsForbidden {
		t.Error("expected forbidden content to be detected (ISO timestamp)")
	}
}

func TestValidateIssue_MissingSections(t *testing.T) {
	validator := NewIssueValidator(IssueValidatorConfig{
		MinTitleLength: 5,
		MaxTitleLength: 200,
		MinBodyLength:  10,
		RequiredSections: []string{
			"## Summary",
			"## Acceptance Criteria",
		},
	})

	content := `# Implement Feature

## Summary

This is the summary section.

## Technical Details

Some technical details here.
`

	result := validator.Validate(content)

	if result.HasRequiredSections {
		t.Error("expected HasRequiredSections to be false")
	}
	if len(result.MissingSections) != 1 {
		t.Errorf("expected 1 missing section, got %d", len(result.MissingSections))
	}
	if result.MissingSections[0] != "## Acceptance Criteria" {
		t.Errorf("expected missing '## Acceptance Criteria', got '%s'", result.MissingSections[0])
	}
}

func TestSanitizeForbidden(t *testing.T) {
	validator := NewDefaultIssueValidator()

	content := `# Fix Bug

## Summary

This issue was generated by Claude to fix the authentication bug.
We also consulted Gemini for additional insights.
`

	sanitized, removed := validator.SanitizeForbidden(content)

	if len(removed) < 2 {
		t.Errorf("expected at least 2 removed patterns, got %d: %v", len(removed), removed)
	}

	// Verify forbidden content was removed
	if strings.Contains(strings.ToLower(sanitized), "claude") {
		t.Error("expected 'claude' to be removed from sanitized content")
	}
	if strings.Contains(strings.ToLower(sanitized), "gemini") {
		t.Error("expected 'gemini' to be removed from sanitized content")
	}
}

func TestSanitizeAndValidate(t *testing.T) {
	validator := NewIssueValidator(IssueValidatorConfig{
		MinTitleLength:    5,
		MaxTitleLength:    200,
		MinBodyLength:     10,
		ForbiddenPatterns: []string{`(?i)\bclaude\b`},
		SanitizeForbidden: true,
	})

	content := `# Fix Authentication

## Summary

This issue was written by Claude to fix the login system.
The login system needs proper error handling.
`

	sanitized, result := validator.SanitizeAndValidate(content)

	// Should be valid after sanitization
	if result.ContainsForbidden {
		t.Errorf("expected no forbidden content after sanitization, got: %v", result.ForbiddenMatches)
	}

	// Original content should have been modified
	if strings.Contains(sanitized, "Claude") {
		t.Error("expected 'Claude' to be removed from sanitized content")
	}
}

func TestIsValid(t *testing.T) {
	validator := NewDefaultIssueValidator()

	validContent := `# Valid Issue Title

## Summary

This is a valid issue body with sufficient content for validation.
`

	invalidContent := `No title or structure`

	if !validator.IsValid(validContent) {
		t.Error("expected IsValid to return true for valid content")
	}

	if validator.IsValid(invalidContent) {
		t.Error("expected IsValid to return false for invalid content")
	}
}

func TestMustBeValid(t *testing.T) {
	validator := NewDefaultIssueValidator()

	validContent := `# Valid Issue Title

## Summary

This is a valid issue body with sufficient content for validation.
`

	invalidContent := `# X

No summary section.
`

	if err := validator.MustBeValid(validContent); err != nil {
		t.Errorf("expected no error for valid content, got: %v", err)
	}

	if err := validator.MustBeValid(invalidContent); err == nil {
		t.Error("expected error for invalid content")
	}
}

func TestValidationError(t *testing.T) {
	err := &ValidationError{
		Warnings: []string{"title too short", "missing required sections"},
	}

	errMsg := err.Error()

	if !strings.Contains(errMsg, "validation failed") {
		t.Error("expected error message to contain 'validation failed'")
	}
	if !strings.Contains(errMsg, "title too short") {
		t.Error("expected error message to contain 'title too short'")
	}
	if !strings.Contains(errMsg, "missing required sections") {
		t.Error("expected error message to contain 'missing required sections'")
	}
}

func TestCleanupWhitespace(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "multiple spaces",
			input:    "hello    world",
			expected: "hello world",
		},
		{
			name:     "multiple newlines",
			input:    "hello\n\n\n\nworld",
			expected: "hello\n\nworld",
		},
		{
			name:     "trailing spaces",
			input:    "hello   \nworld   ",
			expected: "hello\nworld",
		},
		{
			name:     "tabs",
			input:    "hello\t\tworld",
			expected: "hello world",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			result := cleanupWhitespace(tc.input)
			if result != tc.expected {
				t.Errorf("expected %q, got %q", tc.expected, result)
			}
		})
	}
}

func TestValidateAll(t *testing.T) {
	validator := NewDefaultIssueValidator()

	contents := []string{
		`# Valid Issue

## Summary

This is a valid issue with proper structure.
`,
		`No title here`,
		`# Another Valid Issue

## Summary

Another properly formatted issue body.
`,
	}

	results := validator.ValidateAll(contents)

	if len(results) != 3 {
		t.Fatalf("expected 3 results, got %d", len(results))
	}

	if !results[0].Valid {
		t.Error("expected first result to be valid")
	}
	if results[1].Valid {
		t.Error("expected second result to be invalid")
	}
	if !results[2].Valid {
		t.Error("expected third result to be valid")
	}
}

func TestValidateIssue_CaseInsensitiveSections(t *testing.T) {
	validator := NewIssueValidator(IssueValidatorConfig{
		MinTitleLength: 5,
		MaxTitleLength: 200,
		MinBodyLength:  10,
		RequiredSections: []string{
			"## Summary",
		},
	})

	// Test with lowercase
	content := `# Test Issue

## summary

This is a valid issue with lowercase summary heading.
`

	result := validator.Validate(content)

	if !result.HasRequiredSections {
		t.Error("expected HasRequiredSections to be true (case-insensitive matching)")
	}
}

func TestDefaultIssueValidatorConfig(t *testing.T) {
	cfg := DefaultIssueValidatorConfig()

	if cfg.MinTitleLength != 5 {
		t.Errorf("expected MinTitleLength=5, got %d", cfg.MinTitleLength)
	}
	if cfg.MaxTitleLength != 200 {
		t.Errorf("expected MaxTitleLength=200, got %d", cfg.MaxTitleLength)
	}
	if cfg.MinBodyLength != 50 {
		t.Errorf("expected MinBodyLength=50, got %d", cfg.MinBodyLength)
	}
	if len(cfg.RequiredSections) == 0 {
		t.Error("expected non-empty RequiredSections")
	}
	if len(cfg.ForbiddenPatterns) == 0 {
		t.Error("expected non-empty ForbiddenPatterns")
	}
	if !cfg.SanitizeForbidden {
		t.Error("expected SanitizeForbidden to be true by default")
	}
}
